# **ПМ05. Разработка модулей информационной системы и реализация алгоритмов**

## **1. Архитектура модульной системы**

### **1.1. Структура модулей backend**

```
src/
├── modules/
│   ├── auth/                    # Модуль аутентификации
│   ├── products/               # Модуль товаров
│   ├── orders/                 # Модуль заказов
│   ├── payments/               # Модуль платежей
│   ├── users/                  # Модуль пользователей
│   └── analytics/              # Модуль аналитики
├── core/                       # Ядро системы
└── shared/                     # Общие компоненты
```

---

## **2. Модуль аутентификации и авторизации**

### **2.1. Модели данных**

```python
# modules/auth/models.py
from django.db import models
from django.contrib.auth.models import AbstractUser
import uuid

class User(AbstractUser):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    email = models.EmailField(unique=True)
    phone = models.CharField(max_length=15, blank=True, null=True)
    email_verified = models.BooleanField(default=False)
    phone_verified = models.BooleanField(default=False)
    mfa_enabled = models.BooleanField(default=False)
    mfa_secret = models.CharField(max_length=32, blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        db_table = 'users'

class UserSession(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    user = models.ForeignKey(User, on_delete=models.CASCADE)
    session_token = models.CharField(max_length=255, unique=True)
    ip_address = models.GenericIPAddressField()
    user_agent = models.TextField()
    expires_at = models.DateTimeField()
    is_active = models.BooleanField(default=True)
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        db_table = 'user_sessions'
```

### **2.2. Сервис аутентификации**

```python
# modules/auth/services.py
import hashlib
import secrets
from datetime import datetime, timedelta
from django.contrib.auth.hashers import make_password, check_password
from django.core.cache import cache
from .models import User, UserSession

class AuthService:
    @staticmethod
    def register_user(email: str, password: str, **extra_fields) -> dict:
        """Регистрация нового пользователя"""
        if User.objects.filter(email=email).exists():
            return {'success': False, 'error': 'User already exists'}
        
        try:
            user = User.objects.create_user(
                email=email,
                password=password,
                username=email,
                **extra_fields
            )
            
            # Генерация email verification token
            verification_token = secrets.token_urlsafe(32)
            cache.set(f'email_verify:{verification_token}', user.id, timeout=3600)
            
            return {
                'success': True,
                'user': user,
                'verification_token': verification_token
            }
            
        except Exception as e:
            return {'success': False, 'error': str(e)}

    @staticmethod
    def authenticate_user(email: str, password: str, ip_address: str) -> dict:
        """Аутентификация пользователя"""
        try:
            user = User.objects.get(email=email)
            
            # Проверка блокировки аккаунта
            if AuthService._is_account_locked(user.id, ip_address):
                return {'success': False, 'error': 'Account temporarily locked'}
            
            if check_password(password, user.password):
                # Сброс счетчика неудачных попыток
                cache.delete(f'failed_attempts:{user.id}:{ip_address}')
                
                # Создание сессии
                session = AuthService._create_session(user, ip_address)
                
                return {
                    'success': True,
                    'user': user,
                    'session_token': session.session_token
                }
            else:
                # Увеличение счетчика неудачных попыток
                AuthService._record_failed_attempt(user.id, ip_address)
                return {'success': False, 'error': 'Invalid credentials'}
                
        except User.DoesNotExist:
            return {'success': False, 'error': 'User not found'}

    @staticmethod
    def _is_account_locked(user_id: str, ip_address: str) -> bool:
        """Проверка блокировки аккаунта"""
        cache_key = f'failed_attempts:{user_id}:{ip_address}'
        attempts = cache.get(cache_key, 0)
        return attempts >= 5

    @staticmethod
    def _record_failed_attempt(user_id: str, ip_address: str):
        """Запись неудачной попытки входа"""
        cache_key = f'failed_attempts:{user_id}:{ip_address}'
        attempts = cache.get(cache_key, 0) + 1
        cache.set(cache_key, attempts, timeout=1800)  # 30 минут

    @staticmethod
    def _create_session(user: User, ip_address: str, user_agent: str = "") -> UserSession:
        """Создание сессии пользователя"""
        session_token = secrets.token_urlsafe(64)
        expires_at = datetime.now() + timedelta(days=30)
        
        session = UserSession.objects.create(
            user=user,
            session_token=session_token,
            ip_address=ip_address,
            user_agent=user_agent,
            expires_at=expires_at
        )
        
        return session
```

### **2.3. API endpoints**

```python
# modules/auth/api.py
from rest_framework import status
from rest_framework.decorators import api_view
from rest_framework.response import Response
from .services import AuthService

@api_view(['POST'])
def register(request):
    """Регистрация пользователя"""
    email = request.data.get('email')
    password = request.data.get('password')
    
    if not email or not password:
        return Response(
            {'error': 'Email and password are required'},
            status=status.HTTP_400_BAD_REQUEST
        )
    
    result = AuthService.register_user(email, password)
    
    if result['success']:
        return Response({
            'message': 'User registered successfully',
            'user_id': str(result['user'].id)
        }, status=status.HTTP_201_CREATED)
    else:
        return Response(
            {'error': result['error']},
            status=status.HTTP_400_BAD_REQUEST
        )

@api_view(['POST'])
def login(request):
    """Вход пользователя"""
    email = request.data.get('email')
    password = request.data.get('password')
    ip_address = request.META.get('REMOTE_ADDR')
    user_agent = request.META.get('HTTP_USER_AGENT', '')
    
    result = AuthService.authenticate_user(email, password, ip_address)
    
    if result['success']:
        return Response({
            'session_token': result['session_token'],
            'user': {
                'id': str(result['user'].id),
                'email': result['user'].email
            }
        })
    else:
        return Response(
            {'error': result['error']},
            status=status.HTTP_401_UNAUTHORIZED
        )
```

---

## **3. Модуль товаров (Products)**

### **3.1. Модели данных**

```python
# modules/products/models.py
from django.db import models
import uuid

class Category(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    name = models.CharField(max_length=100)
    slug = models.SlugField(unique=True)
    description = models.TextField(blank=True)
    parent = models.ForeignKey('self', on_delete=models.CASCADE, null=True, blank=True)
    image = models.ImageField(upload_to='categories/', null=True, blank=True)
    is_active = models.BooleanField(default=True)
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        db_table = 'categories'
        verbose_name_plural = 'Categories'

class Product(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    name = models.CharField(max_length=200)
    slug = models.SlugField(unique=True)
    description = models.TextField()
    short_description = models.TextField(max_length=500)
    price = models.DecimalField(max_digits=10, decimal_places=2)
    compare_price = models.DecimalField(max_digits=10, decimal_places=2, null=True, blank=True)
    cost_price = models.DecimalField(max_digits=10, decimal_places=2, null=True, blank=True)
    sku = models.CharField(max_length=100, unique=True)
    barcode = models.CharField(max_length=100, blank=True)
    quantity = models.IntegerField(default=0)
    low_stock_threshold = models.IntegerField(default=5)
    weight = models.DecimalField(max_digits=8, decimal_places=2, null=True, blank=True)
    dimensions = models.CharField(max_length=100, blank=True)
    
    # Связи
    category = models.ForeignKey(Category, on_delete=models.PROTECT)
    
    # Флаги
    is_featured = models.BooleanField(default=False)
    is_active = models.BooleanField(default=True)
    track_quantity = models.BooleanField(default=True)
    allow_backorder = models.BooleanField(default=False)
    
    # Метаданные
    meta_title = models.CharField(max_length=200, blank=True)
    meta_description = models.TextField(blank=True)
    
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        db_table = 'products'

class ProductImage(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    product = models.ForeignKey(Product, on_delete=models.CASCADE, related_name='images')
    image = models.ImageField(upload_to='products/')
    alt_text = models.CharField(max_length=200, blank=True)
    is_primary = models.BooleanField(default=False)
    sort_order = models.IntegerField(default=0)

    class Meta:
        db_table = 'product_images'
        ordering = ['sort_order', 'created_at']

class ProductVariant(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    product = models.ForeignKey(Product, on_delete=models.CASCADE, related_name='variants')
    sku = models.CharField(max_length=100, unique=True)
    price_adjustment = models.DecimalField(max_digits=10, decimal_places=2, default=0)
    quantity = models.IntegerField(default=0)
    is_active = models.BooleanField(default=True)

    class Meta:
        db_table = 'product_variants'

class VariantAttribute(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    variant = models.ForeignKey(ProductVariant, on_delete=models.CASCADE, related_name='attributes')
    name = models.CharField(max_length=50)  # color, size, etc.
    value = models.CharField(max_length=100)  # red, XL, etc.

    class Meta:
        db_table = 'variant_attributes'
```

### **3.2. Алгоритм поиска и фильтрации**

```python
# modules/products/services/search_service.py
from django.db.models import Q, Value, When, Case, IntegerField
from django.db.models.functions import Concat
from .models import Product, Category

class ProductSearchService:
    
    @staticmethod
    def search_products(
        query: str = None,
        category_slug: str = None,
        min_price: float = None,
        max_price: float = None,
        in_stock: bool = None,
        featured: bool = None,
        sort_by: str = 'relevance',
        page: int = 1,
        page_size: int = 20
    ):
        """Расширенный поиск товаров с фильтрацией и сортировкой"""
        
        # Базовый queryset
        products = Product.objects.filter(is_active=True)
        
        # Текстовый поиск
        if query:
            products = products.filter(
                Q(name__icontains=query) |
                Q(description__icontains=query) |
                Q(short_description__icontains=query) |
                Q(sku__icontains=query)
            )
        
        # Фильтр по категории
        if category_slug:
            products = products.filter(category__slug=category_slug)
        
        # Фильтр по цене
        if min_price is not None:
            products = products.filter(price__gte=min_price)
        if max_price is not None:
            products = products.filter(price__lte=max_price)
        
        # Фильтр по наличию
        if in_stock is not None:
            if in_stock:
                products = products.filter(quantity__gt=0)
            else:
                products = products.filter(quantity=0)
        
        # Фильтр по featured
        if featured is not None:
            products = products.filter(is_featured=featured)
        
        # Сортировка
        products = ProductSearchService._apply_sorting(products, sort_by, query)
        
        # Пагинация
        start = (page - 1) * page_size
        end = start + page_size
        
        return products[start:end], products.count()
    
    @staticmethod
    def _apply_sorting(queryset, sort_by: str, search_query: str = None):
        """Применение сортировки к результатам"""
        
        if sort_by == 'price_asc':
            return queryset.order_by('price')
        elif sort_by == 'price_desc':
            return queryset.order_by('-price')
        elif sort_by == 'name_asc':
            return queryset.order_by('name')
        elif sort_by == 'name_desc':
            return queryset.order_by('-name')
        elif sort_by == 'newest':
            return queryset.order_by('-created_at')
        elif sort_by == 'relevance' and search_query:
            # Сортировка по релевантности при наличии поискового запроса
            return ProductSearchService._sort_by_relevance(queryset, search_query)
        else:
            return queryset.order_by('-created_at')
    
    @staticmethod
    def _sort_by_relevance(queryset, search_query: str):
        """Сортировка по релевантности поиска"""
        
        # Создаем условия для релевантности
        when_name = When(name__icontains=search_query, then=Value(3))
        when_sku = When(sku__icontains=search_query, then=Value(2))
        when_description = When(description__icontains=search_query, then=Value(1))
        
        return queryset.annotate(
            relevance=Case(
                when_name,
                when_sku,
                when_description,
                default=Value(0),
                output_field=IntegerField()
            )
        ).order_by('-relevance', '-created_at')
    
    @staticmethod
    def get_search_suggestions(query: str, limit: int = 5):
        """Получение поисковых подсказок"""
        
        if len(query) < 2:
            return []
        
        products = Product.objects.filter(
            Q(name__icontains=query) |
            Q(sku__icontains=query)
        ).filter(is_active=True)[:limit]
        
        suggestions = []
        for product in products:
            suggestions.append({
                'type': 'product',
                'id': str(product.id),
                'name': product.name,
                'price': float(product.price),
                'image': product.images.filter(is_primary=True).first().image.url if product.images.exists() else None
            })
        
        return suggestions
```

### **3.3. Сервис управления инвентарем**

```python
# modules/products/services/inventory_service.py
from django.db import transaction
from django.core.cache import cache
from ..models import Product, ProductVariant

class InventoryService:
    
    @staticmethod
    @transaction.atomic
    def update_stock(product_id: str, quantity: int, action: str = 'set') -> bool:
        """
        Обновление количества товара
        
        Args:
            product_id: ID товара
            quantity: Количество
            action: Действие ('set', 'add', 'subtract')
        """
        try:
            product = Product.objects.select_for_update().get(id=product_id)
            
            if action == 'set':
                product.quantity = quantity
            elif action == 'add':
                product.quantity += quantity
            elif action == 'subtract':
                product.quantity = max(0, product.quantity - quantity)
            
            product.save()
            
            # Инвалидация кэша
            cache.delete(f'product_{product_id}_stock')
            
            # Проверка низкого запаса
            if product.quantity <= product.low_stock_threshold:
                InventoryService._trigger_low_stock_alert(product)
            
            return True
            
        except Product.DoesNotExist:
            return False
    
    @staticmethod
    def _trigger_low_stock_alert(product: Product):
        """Триггер оповещения о низком запасе"""
        # Здесь может быть интеграция с системой уведомлений
        print(f"Low stock alert for product: {product.name} (SKU: {product.sku})")
    
    @staticmethod
    def reserve_stock(product_id: str, quantity: int) -> bool:
        """Резервирование товара"""
        cache_key = f"reserved_{product_id}"
        currently_reserved = cache.get(cache_key, 0)
        
        product = Product.objects.get(id=product_id)
        available_stock = product.quantity - currently_reserved
        
        if available_stock >= quantity:
            cache.set(cache_key, currently_reserved + quantity, timeout=3600)  # 1 hour
            return True
        
        return False
    
    @staticmethod
    def release_stock(product_id: str, quantity: int):
        """Освобождение зарезервированного товара"""
        cache_key = f"reserved_{product_id}"
        currently_reserved = cache.get(cache_key, 0)
        new_reserved = max(0, currently_reserved - quantity)
        cache.set(cache_key, new_reserved, timeout=3600)
```

---

## **4. Модуль заказов (Orders)**

### **4.1. Модели данных**

```python
# modules/orders/models.py
from django.db import models
import uuid

class Order(models.Model):
    ORDER_STATUS = (
        ('pending', 'Pending'),
        ('confirmed', 'Confirmed'),
        ('processing', 'Processing'),
        ('shipped', 'Shipped'),
        ('delivered', 'Delivered'),
        ('cancelled', 'Cancelled'),
        ('refunded', 'Refunded'),
    )
    
    PAYMENT_STATUS = (
        ('pending', 'Pending'),
        ('paid', 'Paid'),
        ('failed', 'Failed'),
        ('refunded', 'Refunded'),
    )
    
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    order_number = models.CharField(max_length=20, unique=True)
    user = models.ForeignKey('auth.User', on_delete=models.CASCADE, related_name='orders')
    
    # Статусы
    status = models.CharField(max_length=20, choices=ORDER_STATUS, default='pending')
    payment_status = models.CharField(max_length=20, choices=PAYMENT_STATUS, default='pending')
    
    # Цены
    subtotal = models.DecimalField(max_digits=10, decimal_places=2)
    tax_amount = models.DecimalField(max_digits=10, decimal_places=2, default=0)
    shipping_cost = models.DecimalField(max_digits=10, decimal_places=2, default=0)
    discount_amount = models.DecimalField(max_digits=10, decimal_places=2, default=0)
    total = models.DecimalField(max_digits=10, decimal_places=2)
    
    # Информация о доставке
    shipping_address = models.JSONField()  # Сериализованные данные адреса
    billing_address = models.JSONField()
    
    # Временные метки
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    paid_at = models.DateTimeField(null=True, blank=True)
    shipped_at = models.DateTimeField(null=True, blank=True)
    delivered_at = models.DateTimeField(null=True, blank=True)

    class Meta:
        db_table = 'orders'
        ordering = ['-created_at']

class OrderItem(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    order = models.ForeignKey(Order, on_delete=models.CASCADE, related_name='items')
    product = models.ForeignKey('products.Product', on_delete=models.PROTECT)
    variant = models.ForeignKey('products.ProductVariant', on_delete=models.PROTECT, null=True, blank=True)
    
    quantity = models.IntegerField()
    unit_price = models.DecimalField(max_digits=10, decimal_places=2)
    total_price = models.DecimalField(max_digits=10, decimal_places=2)
    
    # Данные на момент заказа (на случай изменения товара)
    product_data = models.JSONField()  # snapshot данных товара

    class Meta:
        db_table = 'order_items'
```

### **4.2. Алгоритм создания заказа**

```python
# modules/orders/services/order_service.py
from django.db import transaction
from decimal import Decimal
from ...products.services.inventory_service import InventoryService
from ..models import Order, OrderItem

class OrderService:
    
    @staticmethod
    @transaction.atomic
    def create_order(user, cart_items, shipping_address, billing_address=None):
        """
        Создание заказа из корзины
        
        Args:
            user: Пользователь
            cart_items: Элементы корзины
            shipping_address: Адрес доставки
            billing_address: Адрес оплаты
        """
        
        if not cart_items:
            raise ValueError("Cart is empty")
        
        billing_address = billing_address or shipping_address
        
        # Расчет стоимостей
        calculation = OrderService._calculate_order_totals(cart_items)
        
        # Создание номера заказа
        order_number = OrderService._generate_order_number()
        
        # Создание заказа
        order = Order.objects.create(
            order_number=order_number,
            user=user,
            subtotal=calculation['subtotal'],
            tax_amount=calculation['tax_amount'],
            shipping_cost=calculation['shipping_cost'],
            discount_amount=calculation['discount_amount'],
            total=calculation['total'],
            shipping_address=shipping_address,
            billing_address=billing_address
        )
        
        # Создание элементов заказа
        for cart_item in cart_items:
            OrderService._create_order_item(order, cart_item)
            
            # Резервирование товара
            if not InventoryService.reserve_stock(cart_item['product_id'], cart_item['quantity']):
                raise Exception(f"Insufficient stock for product {cart_item['product_id']}")
        
        return order
    
    @staticmethod
    def _calculate_order_totals(cart_items):
        """Расчет общей стоимости заказа"""
        subtotal = Decimal('0')
        
        for item in cart_items:
            subtotal += Decimal(str(item['price'])) * item['quantity']
        
        # Пример расчета налогов и доставки
        tax_rate = Decimal('0.20')  # 20% НДС
        tax_amount = subtotal * tax_rate
        
        shipping_cost = Decimal('10.00')  # Фиксированная стоимость доставки
        
        # Скидки (можно расширить)
        discount_amount = Decimal('0')
        
        total = subtotal + tax_amount + shipping_cost - discount_amount
        
        return {
            'subtotal': subtotal,
            'tax_amount': tax_amount,
            'shipping_cost': shipping_cost,
            'discount_amount': discount_amount,
            'total': total
        }
    
    @staticmethod
    def _generate_order_number():
        """Генерация уникального номера заказа"""
        from datetime import datetime
        timestamp = datetime.now().strftime('%Y%m%d%H%M%S')
        random_suffix = str(uuid.uuid4().int)[:6]
        return f"ORD-{timestamp}-{random_suffix}"
    
    @staticmethod
    def _create_order_item(order, cart_item):
        """Создание элемента заказа"""
        from ...products.models import Product
        
        product = Product.objects.get(id=cart_item['product_id'])
        
        # Снимок данных товара
        product_data = {
            'name': product.name,
            'sku': product.sku,
            'price': float(product.price),
            'image': product.images.filter(is_primary=True).first().image.url if product.images.exists() else None
        }
        
        OrderItem.objects.create(
            order=order,
            product=product,
            quantity=cart_item['quantity'],
            unit_price=cart_item['price'],
            total_price=cart_item['price'] * cart_item['quantity'],
            product_data=product_data
        )
```

### **4.3. Алгоритм обработки статусов заказа**

```python
# modules/orders/services/order_workflow.py
from django.db import transaction
from datetime import datetime
from ..models import Order

class OrderWorkflowService:
    
    @staticmethod
    @transaction.atomic
    def confirm_order(order_id: str):
        """Подтверждение заказа"""
        order = Order.objects.select_for_update().get(id=order_id)
        
        if order.status != 'pending':
            raise ValueError(f"Cannot confirm order in {order.status} status")
        
        order.status = 'confirmed'
        order.save()
        
        # Триггер событий
        OrderWorkflowService._on_order_confirmed(order)
    
    @staticmethod
    @transaction.atomic
    def ship_order(order_id: str, tracking_number: str = None):
        """Отметка заказа как отправленного"""
        order = Order.objects.select_for_update().get(id=order_id)
        
        if order.status != 'confirmed' and order.status != 'processing':
            raise ValueError(f"Cannot ship order in {order.status} status")
        
        order.status = 'shipped'
        order.shipped_at = datetime.now()
        order.save()
        
        # Обновление инвентаря
        from ...products.services.inventory_service import InventoryService
        for item in order.items.all():
            InventoryService.update_stock(
                item.product.id, 
                item.quantity, 
                'subtract'
            )
        
        OrderWorkflowService._on_order_shipped(order, tracking_number)
    
    @staticmethod
    def _on_order_confirmed(order: Order):
        """Обработчик подтверждения заказа"""
        # Отправка email подтверждения
        # Создание задач для fulfillment
        pass
    
    @staticmethod
    def _on_order_shipped(order: Order, tracking_number: str):
        """Обработчик отправки заказа"""
        # Отправка email с информацией об отправке
        # Интеграция с системой трекинга
        pass
```

---

## **5. Модуль платежей (Payments)**

### **5.1. Алгоритм обработки платежей**

```python
# modules/payments/services/payment_processor.py
from abc import ABC, abstractmethod
from django.conf import settings
import requests
import json

class PaymentProcessor(ABC):
    """Абстрактный класс процессора платежей"""
    
    @abstractmethod
    def process_payment(self, order, payment_data):
        pass
    
    @abstractmethod
    def refund_payment(self, payment_intent_id, amount):
        pass

class StripePaymentProcessor(PaymentProcessor):
    """Реализация для Stripe"""
    
    def __init__(self):
        self.secret_key = settings.STRIPE_SECRET_KEY
        self.base_url = "https://api.stripe.com/v1"
    
    def process_payment(self, order, payment_data):
        """Обработка платежа через Stripe"""
        
        headers = {
            'Authorization': f'Bearer {self.secret_key}',
            'Content-Type': 'application/x-www-form-urlencoded',
        }
        
        data = {
            'amount': int(order.total * 100),  # Stripe требует сумму в центах
            'currency': 'rub',
            'payment_method': payment_data['payment_method_id'],
            'confirmation_method': 'automatic',
            'confirm': True,
            'return_url': payment_data.get('return_url'),
            'metadata': {
                'order_id': str(order.id),
                'order_number': order.order_number
            }
        }
        
        try:
            response = requests.post(
                f'{self.base_url}/payment_intents',
                headers=headers,
                data=data
            )
            response.raise_for_status()
            
            result = response.json()
            
            return {
                'success': True,
                'payment_intent_id': result['id'],
                'client_secret': result.get('client_secret'),
                'status': result['status']
            }
            
        except requests.exceptions.RequestException as e:
            return {
                'success': False,
                'error': str(e)
            }
    
    def refund_payment(self, payment_intent_id, amount):
        """Создание возврата средств"""
        
        headers = {
            'Authorization': f'Bearer {self.secret_key}',
            'Content-Type': 'application/x-www-form-urlencoded',
        }
        
        data = {
            'payment_intent': payment_intent_id,
            'amount': int(amount * 100),
        }
        
        try:
            response = requests.post(
                f'{self.base_url}/refunds',
                headers=headers,
                data=data
            )
            response.raise_for_status()
            
            return {
                'success': True,
                'refund_id': response.json()['id']
            }
            
        except requests.exceptions.RequestException as e:
            return {
                'success': False,
                'error': str(e)
            }

class PaymentService:
    """Фасад для работы с платежами"""
    
    def __init__(self):
        self.processor = StripePaymentProcessor()  # Можно добавить выбор процессора
    
    def process_order_payment(self, order, payment_data):
        """Обработка платежа для заказа"""
        
        result = self.processor.process_payment(order, payment_data)
        
        if result['success']:
            # Обновление статуса заказа
            order.payment_status = 'paid'
            order.paid_at = datetime.now()
            order.save()
            
            # Подтверждение заказа
            from ...orders.services.order_workflow import OrderWorkflowService
            OrderWorkflowService.confirm_order(order.id)
        
        return result
    
    def create_refund(self, order, amount=None):
        """Создание возврата средств"""
        
        if amount is None:
            amount = order.total
        
        # Поиск payment_intent_id (должен храниться в модели Payment)
        payment_intent_id = self._get_payment_intent_id(order)
        
        if not payment_intent_id:
            return {'success': False, 'error': 'Payment intent not found'}
        
        result = self.processor.refund_payment(payment_intent_id, amount)
        
        if result['success']:
            order.payment_status = 'refunded'
            order.status = 'refunded'
            order.save()
        
        return result
    
    def _get_payment_intent_id(self, order):
        """Получение payment_intent_id для заказа"""
        # В реальной реализации здесь будет запрос к базе данных
        return None
```

---

## **6. Интеграция модулей**

### **6.1. Сервисный слой для координации**

```python
# core/services/ecommerce_service.py
from modules.orders.services.order_service import OrderService
from modules.payments.services.payment_processor import PaymentService
from modules.products.services.search_service import ProductSearchService

class EcommerceService:
    """Фасад для основных ecommerce операций"""
    
    @staticmethod
    def complete_purchase(user, cart_data, shipping_address, payment_data):
        """
        Полный цикл оформления покупки
        """
        
        try:
            # Создание заказа
            order = OrderService.create_order(
                user=user,
                cart_items=cart_data['items'],
                shipping_address=shipping_address
            )
            
            # Обработка платежа
            payment_service = PaymentService()
            payment_result = payment_service.process_order_payment(
                order=order,
                payment_data=payment_data
            )
            
            if not payment_result['success']:
                # Отмена заказа при неудачном платеже
                order.status = 'cancelled'
                order.save()
                return {
                    'success': False,
                    'error': payment_result['error'],
                    'order_id': str(order.id)
                }
            
            return {
                'success': True,
                'order': order,
                'payment': payment_result
            }
            
        except Exception as e:
            return {
                'success': False,
                'error': str(e)
            }
    
    @staticmethod
    def search_products(filters):
        """Унифицированный поиск товаров"""
        return ProductSearchService.search_products(**filters)
```

### **6.2. API endpoints для фронтенда**

```python
# core/api/views.py
from rest_framework.decorators import api_view, authentication_classes, permission_classes
from rest_framework.response import Response
from rest_framework import status
from ..services.ecommerce_service import EcommerceService

@api_view(['POST'])
@authentication_classes([SessionAuthentication])
@permission_classes([IsAuthenticated])
def checkout(request):
    """Endpoint для оформления заказа"""
    
    try:
        result = EcommerceService.complete_purchase(
            user=request.user,
            cart_data=request.data['cart'],
            shipping_address=request.data['shipping_address'],
            payment_data=request.data['payment']
        )
        
        if result['success']:
            return Response({
                'order_number': result['order'].order_number,
                'status': result['order'].status,
                'total': float(result['order'].total)
            }, status=status.HTTP_201_CREATED)
        else:
            return Response(
                {'error': result['error']},
                status=status.HTTP_400_BAD_REQUEST
            )
            
    except Exception as e:
        return Response(
            {'error': 'Internal server error'},
            status=status.HTTP_500_INTERNAL_SERVER_ERROR
        )

@api_view(['GET'])
def product_search(request):
    """Endpoint для поиска товаров"""
    
    filters = {
        'query': request.GET.get('q'),
        'category_slug': request.GET.get('category'),
        'min_price': request.GET.get('min_price'),
        'max_price': request.GET.get('max_price'),
        'in_stock': request.GET.get('in_stock'),
        'sort_by': request.GET.get('sort_by', 'relevance'),
        'page': int(request.GET.get('page', 1)),
        'page_size': int(request.GET.get('page_size', 20))
    }
    
    products, total_count = EcommerceService.search_products(filters)
    
    # Сериализация результатов
    products_data = []
    for product in products:
        products_data.append({
            'id': str(product.id),
            'name': product.name,
            'price': float(product.price),
            'image': product.images.filter(is_primary=True).first().image.url if product.images.exists() else None,
            'in_stock': product.quantity > 0
        })
    
    return Response({
        'products': products_data,
        'total_count': total_count,
        'page': filters['page'],
        'page_size': filters['page_size']
    })
```

---

## **7. Тестирование модулей**

### **7.1. Юнит-тесты для сервисов**

```python
# tests/test_order_service.py
from django.test import TestCase
from modules.orders.services.order_service import OrderService
from modules.products.models import Product, Category

class OrderServiceTestCase(TestCase):
    
    def setUp(self):
        self.category = Category.objects.create(
            name="Test Category",
            slug="test-category"
        )
        
        self.product = Product.objects.create(
            name="Test Product",
            slug="test-product",
            description="Test description",
            price=100.00,
            sku="TEST123",
            quantity=10,
            category=self.category
        )
    
    def test_create_order_success(self):
        """Тест успешного создания заказа"""
        
        from django.contrib.auth import get_user_model
        User = get_user_model()
        user = User.objects.create_user(
            email="test@example.com",
            password="testpass123"
        )
        
        cart_items = [{
            'product_id': str(self.product.id),
            'quantity': 2,
            'price': 100.00
        }]
        
        shipping_address = {
            'first_name': 'John',
            'last_name': 'Doe',
            'street': '123 Main St',
            'city': 'Moscow',
            'zip_code': '123456'
        }
        
        order = OrderService.create_order(
            user=user,
            cart_items=cart_items,
            shipping_address=shipping_address
        )
        
        self.assertEqual(order.user, user)
        self.assertEqual(order.total, 240.00)  # 200 + 20% tax + 10 shipping
        self.assertEqual(order.items.count(), 1)
        
        order_item = order.items.first()
        self.assertEqual(order_item.product, self.product)
        self.assertEqual(order_item.quantity, 2)
```

Данная модульная архитектура обеспечивает:

1. **Четкое разделение ответственности** между модулями
2. **Повторное использование кода** через сервисные классы
3. **Масштабируемость** - каждый модуль можно развивать независимо
4. **Тестируемость** - изолированное тестирование каждого сервиса
5. **Гибкость** - возможность замены реализации отдельных компонентов

Все алгоритмы оптимизированы для работы с большими объемами данных и обеспечивают надежную обработку бизнес-процессов интернет-магазина.
