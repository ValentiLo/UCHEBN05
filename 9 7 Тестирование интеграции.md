# **ПМ05. Тестирование интеграции интернет-магазина**

## **1. Стратегия интеграционного тестирования**

### **1.1. Матрица интеграционных тестов**

```yaml
# integration_test_matrix.yml
integration_points:
  internal_modules:
    - "auth → products"
    - "products → orders" 
    - "orders → payments"
    - "payments → notifications"
    - "users → orders"
    - "cart → orders"

  external_services:
    payment_gateways:
      - "stripe"
      - "cloudpayments"
      - "yookassa"
    shipping_services:
      - "cdek"
      - "boxberry" 
      - "russian_post"
    email_services:
      - "sendgrid"
      - "mailgun"
      - "smtp"
    sms_services:
      - "twilio"
      - "sms_ru"

  data_flows:
    - "user_registration_flow"
    - "product_purchase_flow"
    - "order_fulfillment_flow"
    - "inventory_sync_flow"
    - "analytics_data_flow"
```

---

## **2. Инфраструктура интеграционного тестирования**

### **2.1. Docker Compose для интеграционного тестирования**

```yaml
# docker-compose.integration.yml
version: '3.8'

services:
  # Основные сервисы
  postgres:
    image: postgres:14
    environment:
      POSTGRES_DB: ecommerce_integration
      POSTGRES_USER: test_user
      POSTGRES_PASSWORD: test_password
    ports:
      - "5432:5432"
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U test_user -d ecommerce_integration"]
      interval: 5s
      timeout: 5s
      retries: 5

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 5s
      timeout: 3s
      retries: 5

  app:
    build:
      context: .
      dockerfile: Dockerfile
    environment:
      DATABASE_URL: postgresql://test_user:test_password@postgres:5432/ecommerce_integration
      REDIS_URL: redis://redis:6379/0
      DJANGO_SETTINGS_MODULE: config.settings.integration
      DEBUG: "False"
    ports:
      - "8000:8000"
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    volumes:
      - ./integration_reports:/app/integration_reports

  celery-worker:
    build:
      context: .
      dockerfile: Dockerfile
    environment:
      DATABASE_URL: postgresql://test_user:test_password@postgres:5432/ecommerce_integration
      REDIS_URL: redis://redis:6379/0
      DJANGO_SETTINGS_MODULE: config.settings.integration
    command: celery -A config worker --loglevel=info --concurrency=2
    depends_on:
      - postgres
      - redis
      - app

  celery-beat:
    build:
      context: .
      dockerfile: Dockerfile
    environment:
      DATABASE_URL: postgresql://test_user:test_password@postgres:5432/ecommerce_integration
      REDIS_URL: redis://redis:6379/0
      DJANGO_SETTINGS_MODULE: config.settings.integration
    command: celery -A config beat --loglevel=info
    depends_on:
      - postgres
      - redis
      - app

  # Mock сервисы для внешних интеграций
  mock-payment-service:
    image: mockserver/mockserver
    ports:
      - "1080:1080"
    command: -serverPort 1080 -logLevel INFO

  mock-shipping-service:
    image: mockserver/mockserver
    ports:
      - "1081:1080"
    command: -serverPort 1080 -logLevel INFO

  mock-email-service:
    image: mockserver/mockserver
    ports:
      - "1082:1080"
    command: -serverPort 1080 -logLevel INFO

  # Сервис для тестирования
  integration-tester:
    build:
      context: .
      dockerfile: Dockerfile.integration-test
    environment:
      APP_URL: http://app:8000
      PAYMENT_MOCK_URL: http://mock-payment-service:1080
      SHIPPING_MOCK_URL: http://mock-shipping-service:1080
      EMAIL_MOCK_URL: http://mock-email-service:1080
    depends_on:
      - app
      - mock-payment-service
      - mock-shipping-service
      - mock-email-service
    volumes:
      - ./integration_reports:/app/integration_reports
    command: python scripts/integration_test_runner.py
```

### **2.2. Настройки Django для интеграционного тестирования**

```python
# config/settings/integration.py
from .base import *

DEBUG = False

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': 'ecommerce_integration',
        'USER': 'test_user',
        'PASSWORD': 'test_password',
        'HOST': os.getenv('POSTGRES_HOST', 'localhost'),
        'PORT': '5432',
    }
}

# Настройки для внешних сервисов (mock)
PAYMENT_SERVICE_URL = os.getenv('PAYMENT_MOCK_URL', 'http://localhost:1080')
SHIPPING_SERVICE_URL = os.getenv('SHIPPING_MOCK_URL', 'http://localhost:1081')
EMAIL_SERVICE_URL = os.getenv('EMAIL_MOCK_URL', 'http://localhost:1082')

# Настройки Celery для тестирования
CELERY_BROKER_URL = 'redis://redis:6379/0'
CELERY_RESULT_BACKEND = 'redis://redis:6379/0'

# Отключаем реальные внешние вызовы
PAYMENT_SERVICE_ENABLED = True
SHIPPING_SERVICE_ENABLED = True
EMAIL_SERVICE_ENABLED = True

# Логирование для интеграционных тестов
LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'handlers': {
        'file': {
            'level': 'DEBUG',
            'class': 'logging.FileHandler',
            'filename': '/app/logs/integration_test.log',
        },
        'console': {
            'level': 'INFO',
            'class': 'logging.StreamHandler',
        },
    },
    'loggers': {
        'django': {
            'handlers': ['file', 'console'],
            'level': 'INFO',
            'propagate': True,
        },
        'ecommerce': {
            'handlers': ['file', 'console'],
            'level': 'DEBUG',
            'propagate': False,
        },
    },
}
```

---

## **3. Базовые классы для интеграционного тестирования**

### **3.1. Базовый класс интеграционных тестов**

```python
# tests/integration/test_base.py
import pytest
import requests
from django.test import TestCase
from django.conf import settings
from datetime import datetime
import json

class IntegrationTestBase(TestCase):
    """Базовый класс для интеграционных тестов"""
    
    @classmethod
    def setUpClass(cls):
        super().setUpClass()
        cls.base_url = "http://localhost:8000"
        cls.session = requests.Session()
        cls.test_start_time = datetime.now()
        
    def setUp(self):
        """Настройка перед каждым тестом"""
        self.test_data = {}
        self._setup_mock_services()
        
    def _setup_mock_services(self):
        """Настройка mock сервисов"""
        # Настройка mock платежного сервиса
        self._setup_payment_mock()
        # Настройка mock сервиса доставки
        self._setup_shipping_mock()
        # Настройка mock email сервиса
        self._setup_email_mock()
    
    def _setup_payment_mock(self):
        """Настройка mock платежного сервиса"""
        payment_mock_url = f"{settings.PAYMENT_SERVICE_URL}/mockserver/expectation"
        
        # Mock для создания платежа
        create_payment_expectation = {
            "httpRequest": {
                "method": "POST",
                "path": "/api/v1/payments"
            },
            "httpResponse": {
                "statusCode": 201,
                "body": json.dumps({
                    "id": "pay_test_123",
                    "status": "pending",
                    "confirmation_url": "https://payment-test.com/confirm"
                }),
                "headers": {
                    "Content-Type": ["application/json"]
                }
            }
        }
        
        response = requests.put(payment_mock_url, json=create_payment_expectation)
        assert response.status_code == 201, "Failed to setup payment mock"
    
    def _make_authenticated_request(self, method, endpoint, **kwargs):
        """Выполнение аутентифицированного запроса"""
        headers = kwargs.get('headers', {})
        if hasattr(self, 'auth_token'):
            headers['Authorization'] = f'Bearer {self.auth_token}'
        kwargs['headers'] = headers
        
        url = f"{self.base_url}{endpoint}"
        response = self.session.request(method, url, **kwargs)
        
        # Логирование для отладки
        print(f"{method} {endpoint} -> {response.status_code}")
        
        return response
    
    def create_test_user(self, email="test@example.com", password="testpass123"):
        """Создание тестового пользователя"""
        user_data = {
            "email": email,
            "password": password,
            "first_name": "Test",
            "last_name": "User"
        }
        
        response = self._make_authenticated_request(
            'POST', '/api/auth/register/', 
            json=user_data
        )
        
        if response.status_code == 201:
            self.test_data['user'] = response.json()
            return response.json()
        else:
            # Если пользователь уже существует, логинимся
            login_response = self._make_authenticated_request(
                'POST', '/api/auth/login/',
                json={"email": email, "password": password}
            )
            if login_response.status_code == 200:
                self.auth_token = login_response.json()['access']
                self.test_data['user'] = login_response.json()['user']
                return self.test_data['user']
        
        raise Exception(f"Failed to create test user: {response.text}")
    
    def wait_for_async_task(self, task_id, timeout=30):
        """Ожидание завершения асинхронной задачи"""
        import time
        start_time = time.time()
        
        while time.time() - start_time < timeout:
            response = self._make_authenticated_request(
                'GET', f'/api/tasks/{task_id}/status/'
            )
            
            if response.status_code == 200:
                status = response.json()['status']
                if status in ['SUCCESS', 'FAILURE']:
                    return status
            
            time.sleep(1)
        
        raise TimeoutError(f"Task {task_id} did not complete in {timeout} seconds")
```

### **3.2. Mock сервисы для внешних интеграций**

```python
# tests/integration/mocks/external_services.py
import json
import requests
from datetime import datetime

class PaymentServiceMock:
    """Mock для платежного сервиса"""
    
    def __init__(self, base_url):
        self.base_url = base_url
        self.setup_expectations()
    
    def setup_expectations(self):
        """Настройка ожиданий для mock сервиса"""
        
        # Создание платежа
        self._setup_expectation(
            method="POST",
            path="/api/v1/payments",
            response={
                "statusCode": 201,
                "body": json.dumps({
                    "id": f"pay_mock_{datetime.now().timestamp()}",
                    "status": "pending",
                    "confirmation_url": f"{self.base_url}/confirm/payment",
                    "amount": 1000,
                    "currency": "RUB"
                })
            }
        )
        
        # Проверка статуса платежа
        self._setup_expectation(
            method="GET",
            path="/api/v1/payments/.+",
            response={
                "statusCode": 200,
                "body": json.dumps({
                    "id": "pay_mock_123",
                    "status": "succeeded",
                    "paid": True,
                    "amount": 1000,
                    "currency": "RUB"
                })
            }
        )
        
        # Возврат средств
        self._setup_expectation(
            method="POST",
            path="/api/v1/refunds",
            response={
                "statusCode": 201,
                "body": json.dumps({
                    "id": f"refund_mock_{datetime.now().timestamp()}",
                    "status": "pending",
                    "amount": 1000
                })
            }
        )
    
    def _setup_expectation(self, method, path, response):
        """Установка ожидания для mock сервиса"""
        expectation = {
            "httpRequest": {
                "method": method,
                "path": path
            },
            "httpResponse": response
        }
        
        response = requests.put(
            f"{self.base_url}/mockserver/expectation",
            json=expectation
        )
        assert response.status_code == 201, f"Failed to setup expectation: {response.text}"

class ShippingServiceMock:
    """Mock для сервиса доставки"""
    
    def __init__(self, base_url):
        self.base_url = base_url
        self.setup_expectations()
    
    def setup_expectations(self):
        """Настройка ожиданий для сервиса доставки"""
        
        # Расчет стоимости доставки
        self._setup_expectation(
            method="POST",
            path="/api/v1/shipping/calculate",
            response={
                "statusCode": 200,
                "body": json.dumps({
                    "cost": 250.00,
                    "delivery_days": 3,
                    "service": "standard"
                })
            }
        )
        
        # Создание заказа доставки
        self._setup_expectation(
            method="POST",
            path="/api/v1/shipping/orders",
            response={
                "statusCode": 201,
                "body": json.dumps({
                    "id": f"ship_mock_{datetime.now().timestamp()}",
                    "tracking_number": "TRACK123456",
                    "status": "created"
                })
            }
        )
```

---

## **4. Интеграционные тесты модулей**

### **4.1. Тесты интеграции пользовательских модулей**

```python
# tests/integration/test_user_flows.py
import pytest
from .test_base import IntegrationTestBase
from datetime import datetime

class TestUserRegistrationFlow(IntegrationTestBase):
    """Тесты потока регистрации пользователя"""
    
    def test_complete_user_registration_flow(self):
        """Полный тест потока регистрации пользователя"""
        # 1. Регистрация пользователя
        user_data = {
            "email": f"test_{datetime.now().timestamp()}@example.com",
            "password": "TestPassword123!",
            "first_name": "Integration",
            "last_name": "Test",
            "phone": "+79123456789"
        }
        
        response = self._make_authenticated_request(
            'POST', '/api/auth/register/',
            json=user_data
        )
        
        assert response.status_code == 201
        user_response = response.json()
        assert 'user' in user_response
        assert 'access_token' in user_response
        
        # Сохраняем токен для последующих запросов
        self.auth_token = user_response['access_token']
        
        # 2. Проверка верификации email (mock)
        verification_response = self._make_authenticated_request(
            'POST', '/api/auth/verify-email/',
            json={"token": "mock_verification_token"}
        )
        assert verification_response.status_code in [200, 400]  # Может быть уже верифицирован
        
        # 3. Получение профиля пользователя
        profile_response = self._make_authenticated_request(
            'GET', '/api/users/profile/'
        )
        assert profile_response.status_code == 200
        profile_data = profile_response.json()
        assert profile_data['email'] == user_data['email']
        assert profile_data['first_name'] == user_data['first_name']
        
        # 4. Обновление профиля
        update_data = {
            "first_name": "Updated",
            "last_name": "Name",
            "phone": "+79998887766"
        }
        
        update_response = self._make_authenticated_request(
            'PUT', '/api/users/profile/',
            json=update_data
        )
        assert update_response.status_code == 200
        updated_profile = update_response.json()
        assert updated_profile['first_name'] == "Updated"
        
        # 5. Смена пароля
        password_change_data = {
            "old_password": user_data['password'],
            "new_password": "NewPassword123!"
        }
        
        password_response = self._make_authenticated_request(
            'POST', '/api/auth/change-password/',
            json=password_change_data
        )
        assert password_response.status_code == 200
        
        print("✅ User registration flow completed successfully")

class TestUserOrderFlow(IntegrationTestBase):
    """Тесты потока заказов пользователя"""
    
    def setUp(self):
        super().setUp()
        # Создаем пользователя и продукты для теста
        self.user = self.create_test_user()
        self.products = self._create_test_products()
    
    def _create_test_products(self):
        """Создание тестовых продуктов"""
        products = []
        
        # Создаем несколько тестовых продуктов
        for i in range(3):
            product_data = {
                "name": f"Integration Test Product {i}",
                "description": f"Test product for integration testing {i}",
                "price": 100.00 + (i * 50),
                "sku": f"INT_TEST_{i}_{datetime.now().timestamp()}",
                "quantity": 10
            }
            
            response = self._make_authenticated_request(
                'POST', '/api/products/',
                json=product_data
            )
            
            if response.status_code == 201:
                products.append(response.json())
        
        return products
    
    def test_complete_order_flow(self):
        """Полный тест потока создания заказа"""
        # 1. Добавление товаров в корзину
        cart_items = []
        for product in self.products:
            cart_item = {
                "product_id": product['id'],
                "quantity": 2
            }
            
            response = self._make_authenticated_request(
                'POST', '/api/cart/items/',
                json=cart_item
            )
            assert response.status_code == 201
            cart_items.append(response.json())
        
        # 2. Получение корзины
        cart_response = self._make_authenticated_request('GET', '/api/cart/')
        assert cart_response.status_code == 200
        cart_data = cart_response.json()
        assert len(cart_data['items']) == len(self.products)
        
        # 3. Создание заказа
        order_data = {
            "shipping_address": {
                "first_name": "Test",
                "last_name": "User",
                "street": "Test Street 123",
                "city": "Moscow",
                "postal_code": "123456",
                "country": "RU"
            },
            "billing_address": {
                "first_name": "Test",
                "last_name": "User", 
                "street": "Test Street 123",
                "city": "Moscow",
                "postal_code": "123456",
                "country": "RU"
            },
            "payment_method": "card",
            "shipping_method": "standard"
        }
        
        order_response = self._make_authenticated_request(
            'POST', '/api/orders/',
            json=order_data
        )
        assert order_response.status_code == 201
        order = order_response.json()
        assert order['status'] == 'pending'
        
        # 4. Обработка платежа
        payment_data = {
            "order_id": order['id'],
            "payment_method": "card",
            "payment_token": "mock_payment_token_123"
        }
        
        payment_response = self._make_authenticated_request(
            'POST', '/api/payments/process/',
            json=payment_data
        )
        assert payment_response.status_code == 200
        payment = payment_response.json()
        assert payment['status'] in ['pending', 'succeeded']
        
        # 5. Проверка обновления статуса заказа
        order_status_response = self._make_authenticated_request(
            'GET', f"/api/orders/{order['id']}/"
        )
        assert order_status_response.status_code == 200
        updated_order = order_status_response.json()
        assert updated_order['status'] in ['confirmed', 'processing']
        
        print("✅ Order flow completed successfully")
```

### **4.2. Тесты интеграции платежной системы**

```python
# tests/integration/test_payment_integration.py
import pytest
from .test_base import IntegrationTestBase

class TestPaymentIntegration(IntegrationTestBase):
    """Тесты интеграции с платежными системами"""
    
    def test_payment_processing_flow(self):
        """Тест полного цикла обработки платежа"""
        # Создаем тестовый заказ
        order = self._create_test_order()
        
        # Инициируем платеж
        payment_data = {
            "order_id": order['id'],
            "amount": order['total'],
            "currency": "RUB",
            "payment_method": "card",
            "return_url": "http://localhost:8000/payment/return"
        }
        
        payment_response = self._make_authenticated_request(
            'POST', '/api/payments/create/',
            json=payment_data
        )
        assert payment_response.status_code == 201
        payment = payment_response.json()
        assert 'id' in payment
        assert 'confirmation_url' in payment
        
        # Эмулируем подтверждение платежа
        confirm_data = {
            "payment_id": payment['id'],
            "confirmation_token": "mock_confirmation_token"
        }
        
        confirm_response = self._make_authenticated_request(
            'POST', '/api/payments/confirm/',
            json=confirm_data
        )
        assert confirm_response.status_code == 200
        confirmed_payment = confirm_response.json()
        assert confirmed_payment['status'] == 'succeeded'
        
        # Проверяем обновление статуса заказа
        order_response = self._make_authenticated_request(
            'GET', f"/api/orders/{order['id']}/"
        )
        updated_order = order_response.json()
        assert updated_order['payment_status'] == 'paid'
        assert updated_order['status'] == 'confirmed'
        
        # Проверяем, что отправлено уведомление
        # (проверяем через mock email сервис)
        self._verify_notification_sent('order_confirmation', order['id'])
    
    def test_payment_refund_flow(self):
        """Тест процесса возврата платежа"""
        # Создаем оплаченный заказ
        order = self._create_paid_order()
        
        # Инициируем возврат
        refund_data = {
            "order_id": order['id'],
            "amount": order['total'],
            "reason": "customer_request"
        }
        
        refund_response = self._make_authenticated_request(
            'POST', '/api/payments/refund/',
            json=refund_data
        )
        assert refund_response.status_code == 201
        refund = refund_response.json()
        assert refund['status'] == 'pending'
        
        # Проверяем обновление статуса заказа
        order_response = self._make_authenticated_request(
            'GET', f"/api/orders/{order['id']}/"
        )
        updated_order = order_response.json()
        assert updated_order['payment_status'] == 'refunded'
        assert updated_order['status'] == 'refunded'
    
    def _create_test_order(self):
        """Создание тестового заказа"""
        # Создаем пользователя и продукты
        self.create_test_user()
        products = self._create_test_products(count=2)
        
        # Создаем заказ
        order_data = {
            "items": [
                {"product_id": products[0]['id'], "quantity": 1},
                {"product_id": products[1]['id'], "quantity": 2}
            ],
            "shipping_address": {
                "first_name": "Test",
                "last_name": "User",
                "street": "Test Street 123",
                "city": "Moscow",
                "postal_code": "123456"
            }
        }
        
        response = self._make_authenticated_request(
            'POST', '/api/orders/',
            json=order_data
        )
        assert response.status_code == 201
        return response.json()
    
    def _verify_notification_sent(self, notification_type, order_id):
        """Проверка отправки уведомления через mock сервис"""
        # Проверяем, что запрос был отправлен в mock email сервис
        verify_url = f"{settings.EMAIL_SERVICE_URL}/mockserver/verify"
        
        verification_request = {
            "httpRequest": {
                "method": "POST",
                "path": "/api/v1/emails/send"
            },
            "times": {
                "atLeast": 1
            }
        }
        
        response = requests.put(verify_url, json=verification_request)
        assert response.status_code == 202, "Notification was not sent"
```

### **4.3. Тесты интеграции с внешними сервисами**

```python
# tests/integration/test_external_services.py
import pytest
import requests
from .test_base import IntegrationTestBase

class TestExternalServicesIntegration(IntegrationTestBase):
    """Тесты интеграции с внешними сервисами"""
    
    def test_shipping_service_integration(self):
        """Тест интеграции с сервисом доставки"""
        # Создаем тестовый заказ
        order = self._create_test_order()
        
        # Запрос расчета стоимости доставки
        shipping_calc_data = {
            "order_id": order['id'],
            "destination": {
                "city": "Moscow",
                "postal_code": "123456"
            },
            "packages": [
                {
                    "weight": 1.5,
                    "dimensions": {"length": 30, "width": 20, "height": 10}
                }
            ]
        }
        
        shipping_response = self._make_authenticated_request(
            'POST', '/api/shipping/calculate/',
            json=shipping_calc_data
        )
        assert shipping_response.status_code == 200
        shipping_quote = shipping_response.json()
        assert 'cost' in shipping_quote
        assert 'delivery_days' in shipping_quote
        
        # Создание заказа доставки
        shipping_order_data = {
            "order_id": order['id'],
            "service": "standard",
            "recipient": {
                "name": "Test User",
                "phone": "+79123456789",
                "address": shipping_calc_data['destination']
            }
        }
        
        create_shipping_response = self._make_authenticated_request(
            'POST', '/api/shipping/create/',
            json=shipping_order_data
        )
        assert create_shipping_response.status_code == 201
        shipping_order = create_shipping_response.json()
        assert 'tracking_number' in shipping_order
        assert 'id' in shipping_order
        
        # Проверка статуса доставки
        tracking_response = self._make_authenticated_request(
            'GET', f"/api/shipping/tracking/{shipping_order['id']}/"
        )
        assert tracking_response.status_code == 200
        tracking_info = tracking_response.json()
        assert 'status' in tracking_info
    
    def test_inventory_sync_integration(self):
        """Тест интеграции синхронизации инвентаря"""
        # Создаем тестовый продукт
        product_data = {
            "name": "Inventory Sync Test Product",
            "description": "Product for inventory sync testing",
            "price": 150.00,
            "sku": "INV_SYNC_TEST",
            "quantity": 50
        }
        
        product_response = self._make_authenticated_request(
            'POST', '/api/products/',
            json=product_data
        )
        product = product_response.json()
        
        # Симулируем продажу (уменьшение количества)
        sale_data = {
            "product_id": product['id'],
            "quantity": 5
        }
        
        # Обновляем инвентарь через API
        inventory_response = self._make_authenticated_request(
            'PUT', f"/api/products/{product['id']}/inventory/",
            json=sale_data
        )
        assert inventory_response.status_code == 200
        
        # Проверяем обновленное количество
        product_check_response = self._make_authenticated_request(
            'GET', f"/api/products/{product['id']}/"
        )
        updated_product = product_check_response.json()
        assert updated_product['quantity'] == 45
        
        # Проверяем синхронизацию с внешними системами
        # (если есть интеграция с ERP/WMS)
        self._verify_external_inventory_sync(product['id'])
    
    def test_analytics_integration(self):
        """Тест интеграции с аналитическими сервисами"""
        # Создаем тестовые события
        events = [
            {
                "type": "page_view",
                "page": "/products/1",
                "user_agent": "integration-test"
            },
            {
                "type": "add_to_cart", 
                "product_id": "test_product_1",
                "quantity": 2
            },
            {
                "type": "purchase",
                "order_id": "test_order_123",
                "amount": 200.00
            }
        ]
        
        for event in events:
            analytics_response = self._make_authenticated_request(
                'POST', '/api/analytics/track/',
                json=event
            )
            assert analytics_response.status_code == 200
        
        # Проверяем агрегированные данные
        stats_response = self._make_authenticated_request(
            'GET', '/api/analytics/stats/'
        )
        assert stats_response.status_code == 200
        stats = stats_response.json()
        
        # Проверяем, что данные собираются
        assert 'page_views' in stats
        assert 'conversion_rate' in stats
```

---

## **5. Тестирование асинхронных процессов**

### **5.1. Тесты Celery задач и фоновых процессов**

```python
# tests/integration/test_async_processes.py
import pytest
import time
from celery.result import AsyncResult
from .test_base import IntegrationTestBase

class TestAsyncProcessesIntegration(IntegrationTestBase):
    """Тесты асинхронных процессов и Celery задач"""
    
    def test_order_processing_workflow(self):
        """Тест асинхронного процесса обработки заказа"""
        # Создаем тестовый заказ
        order = self._create_test_order()
        
        # Запускаем процесс обработки заказа
        process_response = self._make_authenticated_request(
            'POST', f"/api/orders/{order['id']}/process/"
        )
        assert process_response.status_code == 202
        process_data = process_response.json()
        assert 'task_id' in process_data
        
        # Ожидаем завершения задачи
        task_status = self.wait_for_async_task(process_data['task_id'])
        assert task_status == 'SUCCESS'
        
        # Проверяем результаты обработки
        order_response = self._make_authenticated_request(
            'GET', f"/api/orders/{order['id']}/"
        )
        processed_order = order_response.json()
        
        # Проверяем, что все этапы выполнены
        assert processed_order['status'] == 'processing'
        assert processed_order['inventory_reserved'] == True
        assert processed_order['payment_processed'] == True
        assert processed_order['shipping_created'] == True
    
    def test_inventory_management_workflow(self):
        """Тест асинхронного управления инвентарем"""
        # Создаем тестовые продукты
        products = self._create_test_products(count=3)
        
        # Запускаем задачу синхронизации инвентаря
        sync_response = self._make_authenticated_request(
            'POST', '/api/inventory/sync/'
        )
        assert sync_response.status_code == 202
        sync_data = sync_response.json()
        
        # Ожидаем завершения синхронизации
        task_status = self.wait_for_async_task(sync_data['task_id'])
        assert task_status == 'SUCCESS'
        
        # Проверяем результаты синхронизации
        inventory_response = self._make_authenticated_request(
            'GET', '/api/inventory/status/'
        )
        inventory_status = inventory_response.json()
        assert inventory_status['last_sync'] is not None
        assert inventory_status['products_synced'] >= len(products)
    
    def test_notification_system_workflow(self):
        """Тест асинхронной системы уведомлений"""
        # Создаем тестовый заказ
        order = self._create_test_order()
        
        # Запускаем отправку уведомлений
        notification_data = {
            "order_id": order['id'],
            "notification_type": "order_created"
        }
        
        notify_response = self._make_authenticated_request(
            'POST', '/api/notifications/send/',
            json=notification_data
        )
        assert notify_response.status_code == 202
        notify_data = notify_response.json()
        
        # Ожидаем завершения отправки
        task_status = self.wait_for_async_task(notify_data['task_id'])
        assert task_status == 'SUCCESS'
        
        # Проверяем, что уведомления были отправлены
        notifications_response = self._make_authenticated_request(
            'GET', f"/api/notifications/order/{order['id']}/"
        )
        notifications = notifications_response.json()
        assert len(notifications) > 0
        
        # Проверяем, что email был отправлен
        email_sent = any(n['type'] == 'email' for n in notifications)
        assert email_sent == True
        
        # Проверяем через mock, что запросы были к email сервису
        self._verify_email_service_called()
    
    def _verify_email_service_called(self):
        """Проверка вызовов email сервиса через mock"""
        verify_url = f"{settings.EMAIL_SERVICE_URL}/mockserver/verify"
        
        verification_request = {
            "httpRequest": {
                "method": "POST",
                "path": "/api/v1/emails/send"
            },
            "times": {
                "atLeast": 1
            }
        }
        
        response = requests.put(verify_url, json=verification_request)
        assert response.status_code == 202, "Email service was not called"
```

---

## **6. Запуск и отчетность интеграционных тестов**

### **6.1. Скрипт запуска интеграционных тестов**

```python
#!/usr/bin/env python3
# scripts/integration_test_runner.py
import os
import sys
import subprocess
import json
import time
import requests
from datetime import datetime

class IntegrationTestRunner:
    """Запуск интеграционных тестов"""
    
    def __init__(self):
        self.results = {}
        self.start_time = datetime.now()
        self.base_url = "http://localhost:8000"
    
    def wait_for_services(self, timeout=300):
        """Ожидание готовности сервисов"""
        print("⏳ Waiting for services to be ready...")
        
        start_time = time.time()
        services_ready = False
        
        while time.time() - start_time < timeout:
            try:
                # Проверяем доступность основного приложения
                response = requests.get(f"{self.base_url}/health/", timeout=5)
                if response.status_code == 200:
                    health_data = response.json()
                    if all(health_data.values()):
                        services_ready = True
                        break
            except requests.exceptions.RequestException:
                pass
            
            time.sleep(5)
        
        if not services_ready:
            raise Exception("Services did not become ready in time")
        
        print("✅ All services are ready")
    
    def run_integration_tests(self):
        """Запуск интеграционных тестов"""
        print("🚀 Starting integration tests...")
        
        # Ожидаем готовности сервисов
        self.wait_for_services()
        
        # Запускаем тесты
        test_categories = [
            "tests.integration.test_user_flows",
            "tests.integration.test_payment_integration", 
            "tests.integration.test_external_services",
            "tests.integration.test_async_processes"
        ]
        
        for test_category in test_categories:
            print(f"\n📋 Running {test_category}...")
            
            try:
                result = subprocess.run([
                    "python", "manage.py", "test",
                    test_category,
                    "--verbosity=2",
                    "--no-input",
                    f"--junitxml=integration_reports/{test_category.split('.')[-1]}_results.xml"
                ], capture_output=True, text=True, timeout=600)
                
                self.results[test_category] = {
                    "exit_code": result.returncode,
                    "success": result.returncode == 0,
                    "stdout": result.stdout,
                    "stderr": result.stderr
                }
                
                if result.returncode == 0:
                    print(f"✅ {test_category}: PASSED")
                else:
                    print(f"❌ {test_category}: FAILED")
                    
            except subprocess.TimeoutExpired:
                self.results[test_category] = {
                    "exit_code": -1,
                    "success": False,
                    "error": "Timeout expired"
                }
                print(f"⏰ {test_category}: TIMEOUT")
        
        self.generate_integration_report()
        return self.results
    
    def generate_integration_report(self):
        """Генерация отчета интеграционного тестирования"""
        end_time = datetime.now()
        duration = (end_time - self.start_time).total_seconds()
        
        report = {
            "integration_test_report": {
                "start_time": self.start_time.isoformat(),
                "end_time": end_time.isoformat(),
                "duration_seconds": duration,
                "total_test_categories": len(self.results),
                "passed_categories": sum(1 for r in self.results.values() if r["success"]),
                "failed_categories": sum(1 for r in self.results.values() if not r["success"]),
                "success_rate": (sum(1 for r in self.results.values() if r["success"]) / len(self.results)) * 100
            },
            "test_results": self.results
        }
        
        # Сохраняем отчет
        os.makedirs("integration_reports", exist_ok=True)
        report_file = f"integration_reports/integration_test_{self.start_time.strftime('%Y%m%d_%H%M%S')}.json"
        
        with open(report_file, 'w') as f:
            json.dump(report, f, indent=2, ensure_ascii=False)
        
        # Выводим сводку
        print("\n" + "="*60)
        print("INTEGRATION TESTING SUMMARY")
        print("="*60)
        print(f"Duration: {duration:.2f} seconds")
        print(f"Success Rate: {report['integration_test_report']['success_rate']:.1f}%")
        print(f"Passed: {report['integration_test_report']['passed_categories']}")
        print(f"Failed: {report['integration_test_report']['failed_categories']}")
        print("="*60)
        
        return report

if __name__ == "__main__":
    runner = IntegrationTestRunner()
    
    try:
        results = runner.run_integration_tests()
        
        # Возвращаем код выхода на основе результатов
        success_rate = results['integration_test_report']['success_rate']
        sys.exit(0 if success_rate >= 80 else 1)
        
    except Exception as e:
        print(f"❌ Integration testing failed: {str(e)}")
        sys.exit(1)
```

### **6.2. GitHub Actions workflow для интеграционного тестирования**

```yaml
# .github/workflows/integration-tests.yml
name: Integration Tests

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  schedule:
    - cron: '0 1 * * *'  # Ежедневно в 1:00

jobs:
  integration-tests:
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:14
        env:
          POSTGRES_DB: ecommerce_integration
          POSTGRES_USER: test_user
          POSTGRES_PASSWORD: test_password
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
      
      redis:
        image: redis:7-alpine
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379
      
      mock-payment:
        image: mockserver/mockserver
        ports:
          - 1080:1080
        
      mock-shipping:
        image: mockserver/mockserver  
        ports:
          - 1081:1080
          
      mock-email:
        image: mockserver/mockserver
        ports:
          - 1082:1080

    steps:
    - name: Checkout code
      uses: actions/checkout@v3
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install -r requirements-test.txt
    
    - name: Setup test database
      env:
        DATABASE_URL: postgresql://test_user:test_password@localhost:5432/ecommerce_integration
        DJANGO_SETTINGS_MODULE: config.settings.integration
      run: |
        python manage.py migrate
        python manage.py collectstatic --noinput
    
    - name: Start application
      env:
        DATABASE_URL: postgresql://test_user:test_password@localhost:5432/ecommerce_integration
        REDIS_URL: redis://localhost:6379/0
        DJANGO_SETTINGS_MODULE: config.settings.integration
        PAYMENT_MOCK_URL: http://localhost:1080
        SHIPPING_MOCK_URL: http://localhost:1081
        EMAIL_MOCK_URL: http://localhost:1082
      run: |
        python manage.py runserver 8000 &
        celery -A config worker --loglevel=info &
        celery -A config beat --loglevel=info &
    
    - name: Wait for application
      run: |
        timeout 300 bash -c 'until curl -f http://localhost:8000/health/ >/dev/null 2>&1; do
          sleep 5
        done'
    
    - name: Run integration tests
      env:
        APP_URL: http://localhost:8000
        PAYMENT_MOCK_URL: http://localhost:1080
        SHIPPING_MOCK_URL: http://localhost:1081
        EMAIL_MOCK_URL: http://localhost:1082
        DJANGO_SETTINGS_MODULE: config.settings.integration
      run: |
        python scripts/integration_test_runner.py
    
    - name: Upload integration reports
      uses: actions/upload-artifact@v3
      if: always()
      with:
        name: integration-reports
        path: integration_reports/
        retention-days: 30
```

Данная система интеграционного тестирования обеспечивает:

1. **Комплексное тестирование** взаимодействия всех модулей
2. **Изоляцию тестов** через mock сервисы
3. **Автоматизацию** запуска и отчетности
4. **Непрерывную проверку** интеграций в CI/CD
5. **Детальный мониторинг** проблем взаимодействия между компонентами
