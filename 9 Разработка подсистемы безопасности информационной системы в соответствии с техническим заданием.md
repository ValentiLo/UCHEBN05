# **УП05. Разработка подсистемы безопасности информационной системы**

## **1. Архитектура подсистемы безопасности**

### **1.1. Компонентная диаграмма подсистемы безопасности**

```
┌─────────────────────────────────────────────────────────────┐
│                 ПОДСИСТЕМА БЕЗОПАСНОСТИ                     │
├─────────────────────────────────────────────────────────────┤
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐  │
│  │   Модуль    │  │   Модуль    │  │      Модуль         │  │
│  │Аутентификации│  │ Авторизации │  │  Audit & Logging    │  │
│  └─────────────┘  └─────────────┘  └─────────────────────┘  │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐  │
│  │   Модуль    │  │   Модуль    │  │      Модуль         │  │
│  │  Шифрования │  │   WAF       │  │  Мониторинга        │  │
│  └─────────────┘  └─────────────┘  └─────────────────────┘  │
└─────────────────────────────────────────────────────────────┘
```

### **1.2. Технологический стек реализации**

```yaml
backend_framework: "Django 4.2 + Django REST Framework"
authentication: "Simple JWT + OAuth2"
password_hashing: "Argon2"
encryption: "cryptography (AES-256-GCM)"
security_headers: "Django Security Middleware"
api_protection: "DRF Throttling + Custom Permissions"
waf: "Nginx + ModSecurity"
monitoring: "ELK Stack + Prometheus + Grafana"
```

---

## **2. Реализация модуля аутентификации**

### **2.1. Модели данных для аутентификации**

```python
# models.py
from django.contrib.auth.models import AbstractUser
from django.db import models
import uuid

class CustomUser(AbstractUser):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    email = models.EmailField(unique=True)
    phone = models.CharField(max_length=15, blank=True, null=True)
    is_verified = models.BooleanField(default=False)
    mfa_enabled = models.BooleanField(default=False)
    mfa_secret = models.CharField(max_length=32, blank=True)
    last_password_change = models.DateTimeField(auto_now_add=True)
    
    class Meta:
        permissions = [
            ("can_view_audit_logs", "Can view audit logs"),
            ("can_manage_users", "Can manage users"),
        ]

class LoginAttempt(models.Model):
    user = models.ForeignKey(CustomUser, on_delete=models.CASCADE)
    ip_address = models.GenericIPAddressField()
    user_agent = models.TextField()
    timestamp = models.DateTimeField(auto_now_add=True)
    success = models.BooleanField(default=False)
    failure_reason = models.CharField(max_length=100, blank=True)

class PasswordHistory(models.Model):
    user = models.ForeignKey(CustomUser, on_delete=models.CASCADE)
    password_hash = models.CharField(max_length=128)
    created_at = models.DateTimeField(auto_now_add=True)
```

### **2.2. Настройки аутентификации в Django**

```python
# settings.py
AUTH_USER_MODEL = 'security.CustomUser'

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
        'OPTIONS': {'min_length': 10}
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]

# JWT Settings
SIMPLE_JWT = {
    'ACCESS_TOKEN_LIFETIME': timedelta(minutes=15),
    'REFRESH_TOKEN_LIFETIME': timedelta(days=1),
    'ROTATE_REFRESH_TOKENS': True,
    'BLACKLIST_AFTER_ROTATION': True,
    'ALGORITHM': 'HS256',
    'SIGNING_KEY': SECRET_KEY,
    'AUTH_HEADER_TYPES': ('Bearer',),
}

# Session Settings
SESSION_COOKIE_AGE = 1800  # 30 minutes
SESSION_COOKIE_SECURE = True
SESSION_COOKIE_HTTPONLY = True
SESSION_COOKIE_SAMESITE = 'Lax'
```

### **2.3. Сервис аутентификации**

```python
# services/authentication_service.py
import logging
from datetime import datetime, timedelta
from django.core.cache import cache
from django.contrib.auth.hashers import check_password
from rest_framework_simplejwt.tokens import RefreshToken

logger = logging.getLogger('security')

class AuthenticationService:
    
    @staticmethod
    def check_password_strength(password):
        """Проверка сложности пароля"""
        if len(password) < 10:
            return False, "Password must be at least 10 characters long"
        
        if not any(c.isupper() for c in password):
            return False, "Password must contain uppercase letters"
            
        if not any(c.islower() for c in password):
            return False, "Password must contain lowercase letters"
            
        if not any(c.isdigit() for c in password):
            return False, "Password must contain digits"
            
        if not any(c in '!@#$%^&*()_+-=[]{}|;:,.<>?' for c in password):
            return False, "Password must contain special characters"
            
        return True, "Password is strong"
    
    @staticmethod
    def is_account_locked(user, ip_address):
        """Проверка блокировки аккаунта"""
        cache_key = f"login_attempts:{user.id}:{ip_address}"
        attempts = cache.get(cache_key, 0)
        return attempts >= 5
    
    @staticmethod
    def record_login_attempt(user, ip_address, user_agent, success, failure_reason=''):
        """Запись попытки входа"""
        from .models import LoginAttempt
        
        LoginAttempt.objects.create(
            user=user,
            ip_address=ip_address,
            user_agent=user_agent,
            success=success,
            failure_reason=failure_reason
        )
        
        if not success:
            cache_key = f"login_attempts:{user.id}:{ip_address}"
            attempts = cache.get(cache_key, 0) + 1
            cache.set(cache_key, attempts, timeout=1800)  # 30 minutes
    
    @staticmethod
    def generate_tokens(user):
        """Генерация JWT токенов"""
        refresh = RefreshToken.for_user(user)
        return {
            'access': str(refresh.access_token),
            'refresh': str(refresh),
        }
```

---

## **3. Реализация модуля авторизации**

### **3.1. Система ролей и разрешений**

```python
# models/authorization_models.py
from django.db import models

class Role(models.Model):
    name = models.CharField(max_length=50, unique=True)
    description = models.TextField()
    permissions = models.ManyToManyField('auth.Permission')
    is_system = models.BooleanField(default=False)
    
    class Meta:
        db_table = 'security_roles'

class UserRole(models.Model):
    user = models.ForeignKey('security.CustomUser', on_delete=models.CASCADE)
    role = models.ForeignKey(Role, on_delete=models.CASCADE)
    assigned_by = models.ForeignKey('security.CustomUser', 
                                  on_delete=models.SET_NULL, 
                                  null=True, 
                                  related_name='assigned_roles')
    assigned_at = models.DateTimeField(auto_now_add=True)
    expires_at = models.DateTimeField(null=True, blank=True)
    
    class Meta:
        db_table = 'security_user_roles'
        unique_together = ['user', 'role']

# permissions.py
from rest_framework import permissions

class IsOwnerOrAdmin(permissions.BasePermission):
    """Разрешение для владельца объекта или администратора"""
    
    def has_object_permission(self, request, view, obj):
        if request.user.is_staff:
            return True
            
        if hasattr(obj, 'user'):
            return obj.user == request.user
        elif hasattr(obj, 'owner'):
            return obj.owner == request.user
            
        return False

class HasRolePermission(permissions.BasePermission):
    """Разрешение на основе ролей"""
    
    def __init__(self, required_roles):
        self.required_roles = required_roles
    
    def has_permission(self, request, view):
        if not request.user.is_authenticated:
            return False
            
        user_roles = request.user.roles.values_list('name', flat=True)
        return any(role in self.required_roles for role in user_roles)

class RateLimitPermission(permissions.BasePermission):
    """Ограничение частоты запросов"""
    
    def has_permission(self, request, view):
        cache_key = f"rate_limit:{request.user.id}:{view.__class__.__name__}"
        requests = cache.get(cache_key, 0)
        
        if requests >= 100:  # 100 запросов в минуту
            return False
            
        cache.set(cache_key, requests + 1, timeout=60)
        return True
```

### **3.2. Сервис авторизации**

```python
# services/authorization_service.py
from django.contrib.auth.models import Permission
from django.db import transaction

class AuthorizationService:
    
    @staticmethod
    def assign_role(user, role_name, assigned_by, expires_at=None):
        """Назначение роли пользователю"""
        from .models import Role, UserRole
        
        try:
            role = Role.objects.get(name=role_name)
            
            with transaction.atomic():
                UserRole.objects.create(
                    user=user,
                    role=role,
                    assigned_by=assigned_by,
                    expires_at=expires_at
                )
                
            logger.info(f"Role {role_name} assigned to user {user.email}")
            return True
            
        except Role.DoesNotExist:
            logger.error(f"Role {role_name} not found")
            return False
    
    @staticmethod
    def check_permission(user, permission_codename):
        """Проверка разрешения у пользователя"""
        if user.is_superuser:
            return True
            
        # Проверка прямых разрешений
        if user.user_permissions.filter(codename=permission_codename).exists():
            return True
            
        # Проверка разрешений через группы
        if user.groups.filter(permissions__codename=permission_codename).exists():
            return True
            
        # Проверка разрешений через роли
        user_roles = user.roles.all()
        for role in user_roles:
            if role.permissions.filter(codename=permission_codename).exists():
                return True
                
        return False
    
    @staticmethod
    def get_user_permissions(user):
        """Получение всех разрешений пользователя"""
        permissions = set()
        
        # Разрешения пользователя
        permissions.update(user.get_all_permissions())
        
        # Разрешения через роли
        for role in user.roles.all():
            for perm in role.permissions.all():
                permissions.add(f"{perm.content_type.app_label}.{perm.codename}")
                
        return list(permissions)
```

---

## **4. Реализация модуля аудита и логирования**

### **4.1. Модели для аудита**

```python
# models/audit_models.py
class SecurityEvent(models.Model):
    EVENT_TYPES = (
        ('LOGIN_SUCCESS', 'Successful Login'),
        ('LOGIN_FAILED', 'Failed Login'),
        ('PASSWORD_CHANGE', 'Password Change'),
        ('ROLE_ASSIGNMENT', 'Role Assignment'),
        ('DATA_ACCESS', 'Data Access'),
        ('CONFIG_CHANGE', 'Configuration Change'),
    )
    
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    event_type = models.CharField(max_length=50, choices=EVENT_TYPES)
    user = models.ForeignKey('security.CustomUser', on_delete=models.SET_NULL, null=True)
    ip_address = models.GenericIPAddressField()
    user_agent = models.TextField()
    description = models.TextField()
    metadata = models.JSONField(default=dict)
    timestamp = models.DateTimeField(auto_now_add=True)
    
    class Meta:
        db_table = 'security_events'
        indexes = [
            models.Index(fields=['timestamp']),
            models.Index(fields=['event_type']),
            models.Index(fields=['user']),
        ]

class APIAccessLog(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    user = models.ForeignKey('security.CustomUser', on_delete=models.SET_NULL, null=True)
    endpoint = models.CharField(max_length=255)
    method = models.CharField(max_length=10)
    status_code = models.IntegerField()
    request_body = models.TextField(blank=True)
    response_body = models.TextField(blank=True)
    ip_address = models.GenericIPAddressField()
    duration = models.FloatField()  # Время выполнения в секундах
    timestamp = models.DateTimeField(auto_now_add=True)
    
    class Meta:
        db_table = 'security_api_access_logs'
```

### **4.2. Сервис аудита**

```python
# services/audit_service.py
class AuditService:
    
    @staticmethod
    def log_security_event(event_type, user, request, description, metadata=None):
        """Логирование события безопасности"""
        SecurityEvent.objects.create(
            event_type=event_type,
            user=user,
            ip_address=AuditService.get_client_ip(request),
            user_agent=request.META.get('HTTP_USER_AGENT', ''),
            description=description,
            metadata=metadata or {}
        )
    
    @staticmethod
    def log_api_access(user, request, response, duration):
        """Логирование доступа к API"""
        # Не логируем чувствительные данные
        request_body = AuditService.sanitize_request_body(request)
        response_body = AuditService.sanitize_response_body(response)
        
        APIAccessLog.objects.create(
            user=user,
            endpoint=request.path,
            method=request.method,
            status_code=response.status_code,
            request_body=request_body,
            response_body=response_body,
            ip_address=AuditService.get_client_ip(request),
            duration=duration
        )
    
    @staticmethod
    def sanitize_request_body(request):
        """Очистка чувствительных данных из запроса"""
        import copy
        body = copy.deepcopy(request.data) if hasattr(request, 'data') else {}
        
        # Удаляем пароли и токены
        sensitive_fields = ['password', 'token', 'secret', 'key', 'cvv']
        for field in sensitive_fields:
            if field in body:
                body[field] = '***REDACTED***'
                
        return str(body)
    
    @staticmethod
    def get_client_ip(request):
        """Получение IP клиента"""
        x_forwarded_for = request.META.get('HTTP_X_FORWARDED_FOR')
        if x_forwarded_for:
            ip = x_forwarded_for.split(',')[0]
        else:
            ip = request.META.get('REMOTE_ADDR')
        return ip
```

---

## **5. Реализация модуля шифрования**

### **5.1. Сервис шифрования данных**

```python
# services/encryption_service.py
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
import base64
import os

class EncryptionService:
    
    def __init__(self):
        self.key = self._get_encryption_key()
    
    def _get_encryption_key(self):
        """Получение ключа шифрования из настроек"""
        key_from_env = os.getenv('ENCRYPTION_KEY')
        if key_from_env:
            return base64.urlsafe_b64decode(key_from_env)
        else:
            # В продакшене использовать KMS или HSM
            return Fernet.generate_key()
    
    def encrypt_data(self, data):
        """Шифрование данных"""
        if not data:
            return data
            
        f = Fernet(self.key)
        if isinstance(data, str):
            data = data.encode()
            
        encrypted_data = f.encrypt(data)
        return base64.urlsafe_b64encode(encrypted_data).decode()
    
    def decrypt_data(self, encrypted_data):
        """Дешифрование данных"""
        if not encrypted_data:
            return encrypted_data
            
        f = Fernet(self.key)
        try:
            encrypted_data = base64.urlsafe_b64decode(encrypted_data.encode())
            decrypted_data = f.decrypt(encrypted_data)
            return decrypted_data.decode()
        except Exception as e:
            logger.error(f"Decryption error: {str(e)}")
            raise ValueError("Failed to decrypt data")
    
    def hash_sensitive_data(self, data):
        """Хеширование чувствительных данных"""
        import hashlib
        salt = os.urandom(32)
        
        if isinstance(data, str):
            data = data.encode()
            
        hashed = hashlib.pbkdf2_hmac('sha256', data, salt, 100000)
        return base64.b64encode(salt + hashed).decode()
```

---

## **6. Middleware для безопасности**

### **6.1. Кастомные middleware**

```python
# middleware/security_middleware.py
import time
from django.utils.deprecation import MiddlewareMixin

class SecurityHeadersMiddleware(MiddlewareMixin):
    
    def process_response(self, request, response):
        # Установка security headers
        response['Strict-Transport-Security'] = 'max-age=31536000; includeSubDomains'
        response['X-Content-Type-Options'] = 'nosniff'
        response['X-Frame-Options'] = 'DENY'
        response['X-XSS-Protection'] = '1; mode=block'
        response['Referrer-Policy'] = 'strict-origin-when-cross-origin'
        
        # Content Security Policy
        csp = (
            "default-src 'self'; "
            "script-src 'self' 'unsafe-inline'; "
            "style-src 'self' 'unsafe-inline'; "
            "img-src 'self' data: https:; "
            "connect-src 'self'; "
            "frame-ancestors 'none'; "
            "base-uri 'self'; "
            "form-action 'self'"
        )
        response['Content-Security-Policy'] = csp
        
        return response

class APILoggingMiddleware(MiddlewareMixin):
    
    def process_request(self, request):
        request.start_time = time.time()
    
    def process_response(self, request, response):
        if hasattr(request, 'start_time'):
            duration = time.time() - request.start_time
            
            # Логируем только API запросы
            if request.path.startswith('/api/'):
                user = request.user if request.user.is_authenticated else None
                
                from services.audit_service import AuditService
                AuditService.log_api_access(user, request, response, duration)
                
        return response

class RateLimitMiddleware(MiddlewareMixin):
    
    def process_request(self, request):
        if not request.user.is_authenticated:
            return
            
        cache_key = f"global_rate_limit:{request.user.id}"
        requests = cache.get(cache_key, 0)
        
        if requests >= 1000:  # 1000 запросов в час
            from django.http import JsonResponse
            return JsonResponse({
                'error': 'Rate limit exceeded',
                'message': 'Too many requests'
            }, status=429)
            
        cache.set(cache_key, requests + 1, timeout=3600)
```

---

## **7. Конфигурация WAF (Nginx + ModSecurity)**

### **7.1. Конфигурация Nginx**

```nginx
# /etc/nginx/conf.d/security.conf
server {
    listen 443 ssl http2;
    server_name your-domain.com;
    
    # SSL Configuration
    ssl_certificate /path/to/certificate.crt;
    ssl_certificate_key /path/to/private.key;
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512;
    ssl_prefer_server_ciphers off;
    
    # Security Headers
    add_header Strict-Transport-Security "max-age=63072000" always;
    add_header X-Frame-Options DENY always;
    add_header X-Content-Type-Options nosniff always;
    add_header Referrer-Policy "strict-origin-when-cross-origin" always;
    
    # WAF - ModSecurity
    modsecurity on;
    modsecurity_rules_file /etc/nginx/modsecurity/main.conf;
    
    # Rate Limiting
    limit_req_zone $binary_remote_addr zone=api:10m rate=10r/s;
    limit_req_zone $binary_remote_addr zone=auth:10m rate=5r/m;
    
    location /api/ {
        limit_req zone=api burst=20 nodelay;
        proxy_pass http://backend;
        
        # Additional security for API
        modsecurity_rules_file /etc/nginx/modsecurity/api.conf;
    }
    
    location /auth/ {
        limit_req zone=auth burst=10 nodelay;
        proxy_pass http://backend;
    }
    
    # Block common exploits
    location ~* (\.env|\.git|\.htaccess) {
        deny all;
        return 404;
    }
}
```

---

## **8. Мониторинг и алертинг**

### **8.1. Конфигурация Prometheus**

```yaml
# prometheus.yml
scrape_configs:
  - job_name: 'django_app'
    static_configs:
      - targets: ['app:8000']
    metrics_path: '/metrics'
    
  - job_name: 'security_events'
    static_configs:
      - targets: ['app:8000']
    metrics_path: '/security/metrics'

# metrics.py - кастомные метрики безопасности
from prometheus_client import Counter, Histogram, Gauge

security_events = Counter(
    'security_events_total',
    'Total security events',
    ['event_type', 'status']
)

failed_logins = Counter(
    'failed_login_attempts_total',
    'Total failed login attempts',
    ['username', 'ip_address']
)

api_request_duration = Histogram(
    'api_request_duration_seconds',
    'API request duration',
    ['endpoint', 'method', 'status_code']
)
```

### **8.2. Дашборд Grafana**

```json
{
  "dashboard": {
    "title": "Security Monitoring",
    "panels": [
      {
        "title": "Failed Login Attempts",
        "type": "graph",
        "targets": [
          {
            "expr": "rate(failed_login_attempts_total[5m])",
            "legendFormat": "{{username}}"
          }
        ]
      },
      {
        "title": "Security Events by Type",
        "type": "piechart",
        "targets": [
          {
            "expr": "security_events_total",
            "legendFormat": "{{event_type}}"
          }
        ]
      }
    ]
  }
}
```

---

## **9. Тестирование подсистемы безопасности**

### **9.1. Юнит-тесты**

```python
# tests/test_security.py
from django.test import TestCase
from django.contrib.auth import get_user_model
from services.authentication_service import AuthenticationService

class SecurityTestCase(TestCase):
    
    def setUp(self):
        self.user = get_user_model().objects.create_user(
            email='test@example.com',
            password='TestPassword123!'
        )
    
    def test_password_strength_check(self):
        """Тест проверки сложности пароля"""
        # Слабый пароль
        is_strong, message = AuthenticationService.check_password_strength('123')
        self.assertFalse(is_strong)
        
        # Сильный пароль
        is_strong, message = AuthenticationService.check_password_strength('StrongPass123!')
        self.assertTrue(is_strong)
    
    def test_account_lockout(self):
        """Тест блокировки аккаунта"""
        ip_address = '192.168.1.1'
        
        # Симулируем 5 неудачных попыток входа
        for i in range(5):
            AuthenticationService.record_login_attempt(
                self.user, ip_address, 'test-agent', False, 'wrong_password'
            )
        
        # Проверяем блокировку
        is_locked = AuthenticationService.is_account_locked(self.user, ip_address)
        self.assertTrue(is_locked)
```

---

## **10. Развертывание и мониторинг**

### **10.1. Docker Compose для безопасности**

```yaml
# docker-compose.security.yml
version: '3.8'

services:
  waf:
    image: owasp/modsecurity-crs:nginx
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./modsecurity:/etc/modsecurity.d
      - ./ssl:/etc/nginx/ssl
    depends_on:
      - app

  siem:
    image: elastic/elasticsearch:8.5.0
    environment:
      - discovery.type=single-node
      - xpack.security.enabled=false
    volumes:
      - es_data:/usr/share/elasticsearch/data

  logstash:
    image: elastic/logstash:8.5.0
    volumes:
      - ./logstash.conf:/usr/share/logstash/pipeline/logstash.conf

  kibana:
    image: elastic/kibana:8.5.0
    ports:
      - "5601:5601"
    depends_on:
      - siem

volumes:
  es_data:
```

Данная реализация подсистемы безопасности обеспечивает комплексную защиту интернет-магазина в соответствии с современными стандартами безопасности и требованиями технического задания.
