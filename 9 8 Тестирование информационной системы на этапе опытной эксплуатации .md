# **ПМ05. Тестирование информационной системы на этапе опытной эксплуатации**

## **1. Стратегия опытной эксплуатации и мониторинга**

### **1.1. План опытной эксплуатации**

```yaml
# pilot_operation_plan.yml
pilot_operation:
  duration: "30 дней"
  scope:
    users: "100-500 тестовых пользователей"
    features: "Все основные функции интернет-магазина"
    traffic: "Имитация реальной нагрузки"
  
  monitoring:
    - "Системные метрики (CPU, память, диск)"
    - "Производительность приложения"
    - "Ошибки и исключения"
    - "Пользовательские сессии"
    - "Бизнес-метрики"

  feedback_channels:
    - "In-app feedback форма"
    - "Техническая поддержка"
    - "User analytics"
    - "Автоматические отчеты"
```

---

## **2. Система мониторинга и сбора ошибок**

### **2.1. Конфигурация мониторинга для опытной эксплуатации**

```python
# config/settings/pilot.py
from .production import *

# Специфичные настройки для опытной эксплуатации
DEBUG = False
PILOT_MODE = True

# Расширенное логирование
LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'formatters': {
        'verbose': {
            'format': '{levelname} {asctime} {module} {process:d} {thread:d} {message}',
            'style': '{',
        },
        'simple': {
            'format': '{levelname} {message}',
            'style': '{',
        },
    },
    'handlers': {
        'file': {
            'level': 'INFO',
            'class': 'logging.handlers.RotatingFileHandler',
            'filename': '/var/log/ecommerce/pilot.log',
            'maxBytes': 10485760,  # 10MB
            'backupCount': 10,
            'formatter': 'verbose',
        },
        'error_file': {
            'level': 'ERROR',
            'class': 'logging.handlers.RotatingFileHandler',
            'filename': '/var/log/ecommerce/pilot_errors.log',
            'maxBytes': 10485760,
            'backupCount': 10,
            'formatter': 'verbose',
        },
        'console': {
            'level': 'DEBUG',
            'class': 'logging.StreamHandler',
            'formatter': 'simple',
        },
    },
    'loggers': {
        'django': {
            'handlers': ['file', 'console'],
            'level': 'INFO',
            'propagate': True,
        },
        'ecommerce': {
            'handlers': ['file', 'error_file', 'console'],
            'level': 'DEBUG',
            'propagate': False,
        },
        'performance': {
            'handlers': ['file'],
            'level': 'INFO',
            'propagate': False,
        },
    },
}

# Sentry для отслеживания ошибок
import sentry_sdk
from sentry_sdk.integrations.django import DjangoIntegration
from sentry_sdk.integrations.celery import CeleryIntegration
from sentry_sdk.integrations.redis import RedisIntegration

sentry_sdk.init(
    dsn=os.getenv('SENTRY_DSN_PILOT'),
    integrations=[
        DjangoIntegration(),
        CeleryIntegration(),
        RedisIntegration(),
    ],
    traces_sample_rate=1.0,  # 100% трассировок для пилота
    profiles_sample_rate=1.0,
    send_default_pii=True,
    environment="pilot",
    debug=True,
)

# Мониторинг производительности
DATADOG_CONFIG = {
    'api_key': os.getenv('DATADOG_API_KEY'),
    'app_key': os.getenv('DATADOG_APP_KEY'),
}

# Система сбора пользовательского фидбека
USER_FEEDBACK_ENABLED = True
```

### **2.2. Модели для отслеживания ошибок и фидбека**

```python
# modules/feedback/models.py
from django.db import models
import uuid

class PilotErrorReport(models.Model):
    """Модель для отчетов об ошибках в пилотной эксплуатации"""
    
    ERROR_CATEGORIES = [
        ('ui', 'Пользовательский интерфейс'),
        ('functionality', 'Функциональность'),
        ('performance', 'Производительность'),
        ('security', 'Безопасность'),
        ('integration', 'Интеграция'),
        ('data', 'Данные'),
        ('other', 'Другое'),
    ]
    
    SEVERITY_LEVELS = [
        ('critical', 'Критическая'),
        ('high', 'Высокая'),
        ('medium', 'Средняя'),
        ('low', 'Низкая'),
    ]
    
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    title = models.CharField(max_length=200, verbose_name="Заголовок ошибки")
    description = models.TextField(verbose_name="Описание ошибки")
    steps_to_reproduce = models.TextField(blank=True, verbose_name="Шаги воспроизведения")
    expected_behavior = models.TextField(verbose_name="Ожидаемое поведение")
    actual_behavior = models.TextField(verbose_name="Фактическое поведение")
    
    # Классификация
    category = models.CharField(max_length=20, choices=ERROR_CATEGORIES)
    severity = models.CharField(max_length=10, choices=SEVERITY_LEVELS)
    module = models.CharField(max_length=100, verbose_name="Модуль системы")
    
    # Техническая информация
    url = models.URLField(blank=True, verbose_name="URL страницы")
    user_agent = models.TextField(blank=True)
    browser = models.CharField(max_length=100, blank=True)
    operating_system = models.CharField(max_length=100, blank=True)
    
    # Пользовательская информация
    user = models.ForeignKey('auth.User', on_delete=models.SET_NULL, null=True, blank=True)
    user_email = models.EmailField(blank=True, verbose_name="Email пользователя")
    
    # Статус обработки
    STATUS_CHOICES = [
        ('new', 'Новая'),
        ('investigating', 'Расследуется'),
        ('confirmed', 'Подтверждена'),
        ('in_progress', 'В работе'),
        ('resolved', 'Решена'),
        ('wont_fix', 'Не будет исправлена'),
    ]
    
    status = models.CharField(max_length=15, choices=STATUS_CHOICES, default='new')
    assigned_to = models.ForeignKey('auth.User', on_delete=models.SET_NULL, 
                                  null=True, blank=True, related_name='assigned_errors')
    
    # Временные метки
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    resolved_at = models.DateTimeField(null=True, blank=True)
    
    class Meta:
        db_table = 'pilot_error_reports'
        verbose_name = 'Отчет об ошибке'
        verbose_name_plural = 'Отчеты об ошибках'
        ordering = ['-created_at']

class ErrorComment(models.Model):
    """Комментарии к отчетам об ошибках"""
    
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    error_report = models.ForeignKey(PilotErrorReport, on_delete=models.CASCADE, 
                                   related_name='comments')
    author = models.ForeignKey('auth.User', on_delete=models.CASCADE)
    content = models.TextField(verbose_name="Комментарий")
    is_technical_note = models.BooleanField(default=False, 
                                          verbose_name="Техническая заметка")
    
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        db_table = 'error_comments'
        ordering = ['created_at']

class SystemMetric(models.Model):
    """Метрики системы для мониторинга"""
    
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    metric_type = models.CharField(max_length=50, verbose_name="Тип метрики")
    value = models.FloatField(verbose_name="Значение")
    unit = models.CharField(max_length=20, verbose_name="Единица измерения")
    timestamp = models.DateTimeField(auto_now_add=True)
    
    # Дополнительные данные
    metadata = models.JSONField(default=dict, blank=True)
    
    class Meta:
        db_table = 'system_metrics'
        indexes = [
            models.Index(fields=['metric_type', 'timestamp']),
        ]
```

### **2.3. Middleware для сбора данных опытной эксплуатации**

```python
# core/middleware/pilot_monitoring.py
import time
import logging
from django.db import connection
from django.utils.deprecation import MiddlewareMixin
from modules.feedback.models import SystemMetric

logger = logging.getLogger('ecommerce')

class PilotMonitoringMiddleware(MiddlewareMixin):
    """Middleware для мониторинга в режиме опытной эксплуатации"""
    
    def process_request(self, request):
        request.start_time = time.time()
        request.queries_before = len(connection.queries)
        
        # Логируем информацию о запросе
        if hasattr(request, 'user') and request.user.is_authenticated:
            logger.info(f"Pilot request: {request.method} {request.path} - User: {request.user.email}")
        else:
            logger.info(f"Pilot request: {request.method} {request.path} - Anonymous")
    
    def process_response(self, request, response):
        if hasattr(request, 'start_time'):
            duration = time.time() - request.start_time
            queries_after = len(connection.queries)
            queries_count = queries_after - getattr(request, 'queries_before', 0)
            
            # Сохраняем метрики производительности
            try:
                SystemMetric.objects.create(
                    metric_type='request_duration',
                    value=duration,
                    unit='seconds',
                    metadata={
                        'path': request.path,
                        'method': request.method,
                        'status_code': response.status_code,
                        'queries_count': queries_count
                    }
                )
                
                # Логируем медленные запросы
                if duration > 2.0:
                    logger.warning(
                        f"Slow request detected: {request.method} {request.path} "
                        f"took {duration:.2f}s with {queries_count} queries"
                    )
                
                # Логируем запросы с большим количеством SQL запросов
                if queries_count > 20:
                    logger.warning(
                        f"High query count: {request.method} {request.path} "
                        f"executed {queries_count} queries"
                    )
                    
            except Exception as e:
                logger.error(f"Failed to save system metrics: {str(e)}")
        
        return response
    
    def process_exception(self, request, exception):
        """Обработка исключений в режиме пилота"""
        logger.error(
            f"Pilot exception: {request.method} {request.path}",
            exc_info=True,
            extra={
                'user': getattr(request.user, 'email', 'anonymous'),
                'user_agent': request.META.get('HTTP_USER_AGENT', ''),
            }
        )

class UserBehaviorMiddleware(MiddlewareMixin):
    """Middleware для отслеживания поведения пользователей"""
    
    def process_response(self, request, response):
        # Отслеживаем ключевые действия пользователей
        if (response.status_code == 200 and 
            hasattr(request, 'user') and 
            request.user.is_authenticated):
            
            key_actions = [
                '/cart/add/',
                '/checkout/',
                '/orders/create/',
                '/products/search/',
            ]
            
            for action in key_actions:
                if action in request.path:
                    logger.info(
                        f"User action: {request.user.email} - {request.path}",
                        extra={'action': action}
                    )
                    break
        
        return response
```

---

## **3. Система сбора и анализа ошибок**

### **3.1. Сервис для управления ошибками**

```python
# modules/feedback/services/error_tracking.py
import logging
from datetime import datetime, timedelta
from django.db.models import Count, Q
from django.core.mail import send_mail
from ..models import PilotErrorReport, SystemMetric

logger = logging.getLogger('ecommerce')

class ErrorTrackingService:
    """Сервис для отслеживания и управления ошибками"""
    
    @classmethod
    def create_error_report(cls, data, user=None):
        """Создание отчета об ошибке"""
        
        error_report = PilotErrorReport.objects.create(
            title=data.get('title', 'Без названия'),
            description=data['description'],
            steps_to_reproduce=data.get('steps_to_reproduce', ''),
            expected_behavior=data.get('expected_behavior', ''),
            actual_behavior=data.get('actual_behavior', ''),
            category=data.get('category', 'other'),
            severity=data.get('severity', 'medium'),
            module=data.get('module', 'unknown'),
            url=data.get('url', ''),
            user_agent=data.get('user_agent', ''),
            browser=data.get('browser', ''),
            operating_system=data.get('operating_system', ''),
            user=user,
            user_email=data.get('user_email', ''),
        )
        
        # Отправка уведомления
        cls._send_error_notification(error_report)
        
        logger.info(f"New error report created: {error_report.id}")
        return error_report
    
    @classmethod
    def _send_error_notification(cls, error_report):
        """Отправка уведомления о новой ошибке"""
        try:
            subject = f"🚨 Новая ошибка в пилотной эксплуатации: {error_report.title}"
            
            message = f"""
            Обнаружена новая ошибка в системе:
            
            Заголовок: {error_report.title}
            Модуль: {error_report.module}
            Категория: {error_report.get_category_display()}
            Серьезность: {error_report.get_severity_display()}
            
            Описание:
            {error_report.description}
            
            URL: {error_report.url}
            Пользователь: {error_report.user_email or 'Не указан'}
            Время: {error_report.created_at}
            
            Ссылка на ошибку: https://admin.example.com/feedback/errors/{error_report.id}/
            """
            
            # Отправка email команде разработки
            send_mail(
                subject=subject,
                message=message.strip(),
                from_email='noreply@example.com',
                recipient_list=['dev-team@example.com', 'qa-team@example.com'],
                fail_silently=True,
            )
            
        except Exception as e:
            logger.error(f"Failed to send error notification: {str(e)}")
    
    @classmethod
    def get_error_statistics(cls, days=7):
        """Получение статистики по ошибкам"""
        
        start_date = datetime.now() - timedelta(days=days)
        
        stats = {
            'total_errors': PilotErrorReport.objects.filter(
                created_at__gte=start_date
            ).count(),
            
            'by_category': PilotErrorReport.objects.filter(
                created_at__gte=start_date
            ).values('category').annotate(
                count=Count('id')
            ).order_by('-count'),
            
            'by_severity': PilotErrorReport.objects.filter(
                created_at__gte=start_date
            ).values('severity').annotate(
                count=Count('id')
            ).order_by('-count'),
            
            'by_status': PilotErrorReport.objects.filter(
                created_at__gte=start_date
            ).values('status').annotate(
                count=Count('id')
            ).order_by('-count'),
            
            'by_module': PilotErrorReport.objects.filter(
                created_at__gte=start_date
            ).values('module').annotate(
                count=Count('id')
            ).order_by('-count'),
            
            'unresolved_critical': PilotErrorReport.objects.filter(
                severity='critical',
                status__in=['new', 'investigating', 'confirmed', 'in_progress']
            ).count(),
        }
        
        return stats
    
    @classmethod
    def find_similar_errors(cls, error_report):
        """Поиск похожих ошибок"""
        
        similar_errors = PilotErrorReport.objects.filter(
            Q(title__icontains=error_report.title.split()[0]) |
            Q(description__icontains=error_report.description[:100]),
            created_at__gte=datetime.now() - timedelta(days=30)
        ).exclude(id=error_report.id)
        
        return similar_errors
    
    @classmethod
    def generate_daily_report(cls):
        """Генерация ежедневного отчета по ошибкам"""
        
        yesterday = datetime.now() - timedelta(days=1)
        
        new_errors = PilotErrorReport.objects.filter(
            created_at__gte=yesterday
        ).count()
        
        resolved_errors = PilotErrorReport.objects.filter(
            status='resolved',
            resolved_at__gte=yesterday
        ).count()
        
        critical_errors = PilotErrorReport.objects.filter(
            severity='critical',
            status__in=['new', 'investigating', 'confirmed']
        ).count()
        
        # Статистика производительности
        slow_requests = SystemMetric.objects.filter(
            metric_type='request_duration',
            value__gt=2.0,
            timestamp__gte=yesterday
        ).count()
        
        report = {
            'date': datetime.now().strftime('%Y-%m-%d'),
            'new_errors': new_errors,
            'resolved_errors': resolved_errors,
            'critical_errors': critical_errors,
            'slow_requests': slow_requests,
            'top_error_categories': cls.get_error_statistics(1)['by_category'][:5]
        }
        
        return report
```

### **3.2. API для сбора ошибок от клиентов**

```python
# modules/feedback/api/views.py
from rest_framework import viewsets, status
from rest_framework.decorators import action
from rest_framework.response import Response
from django.utils.decorators import method_decorator
from django.views.decorators.csrf import csrf_exempt
from ..models import PilotErrorReport, ErrorComment
from ..services.error_tracking import ErrorTrackingService
from .serializers import ErrorReportSerializer, ErrorCommentSerializer

class ErrorReportViewSet(viewsets.ModelViewSet):
    """API для работы с отчетами об ошибках"""
    
    queryset = PilotErrorReport.objects.all()
    serializer_class = ErrorReportSerializer
    
    def create(self, request):
        """Создание отчета об ошибке"""
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        
        user = request.user if request.user.is_authenticated else None
        
        error_report = ErrorTrackingService.create_error_report(
            serializer.validated_data,
            user=user
        )
        
        return Response(
            ErrorReportSerializer(error_report).data,
            status=status.HTTP_201_CREATED
        )
    
    @action(detail=True, methods=['post'])
    def add_comment(self, request, pk=None):
        """Добавление комментария к ошибке"""
        error_report = self.get_object()
        
        comment_serializer = ErrorCommentSerializer(data=request.data)
        comment_serializer.is_valid(raise_exception=True)
        
        comment = ErrorComment.objects.create(
            error_report=error_report,
            author=request.user,
            content=comment_serializer.validated_data['content'],
            is_technical_note=comment_serializer.validated_data.get('is_technical_note', False)
        )
        
        return Response(
            ErrorCommentSerializer(comment).data,
            status=status.HTTP_201_CREATED
        )
    
    @action(detail=False, methods=['get'])
    def statistics(self, request):
        """Получение статистики по ошибкам"""
        days = int(request.query_params.get('days', 7))
        
        stats = ErrorTrackingService.get_error_statistics(days)
        return Response(stats)
    
    @action(detail=False, methods=['get'])
    def daily_report(self, request):
        """Получение ежедневного отчета"""
        report = ErrorTrackingService.generate_daily_report()
        return Response(report)

# API endpoint для фронтенда (без аутентификации)
@method_decorator(csrf_exempt, name='dispatch')
class PublicErrorReportViewSet(viewsets.ViewSet):
    """Публичный API для отправки ошибок"""
    
    def create(self, request):
        """Публичное создание отчета об ошибке"""
        serializer = ErrorReportSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        
        error_report = ErrorTrackingService.create_error_report(
            serializer.validated_data
        )
        
        return Response(
            {'id': str(error_report.id), 'status': 'created'},
            status=status.HTTP_201_CREATED
        )
```

---

## **4. Инструменты автоматического тестирования в production-like среде**

### **4.1. Скрипты мониторинга и тестирования**

```python
#!/usr/bin/env python3
# scripts/pilot_health_check.py
import requests
import json
import time
import smtplib
from datetime import datetime
from email.mime.text import MIMEText

class PilotHealthChecker:
    """Проверка здоровья системы в режиме пилотной эксплуатации"""
    
    def __init__(self, base_url):
        self.base_url = base_url
        self.results = []
    
    def run_full_health_check(self):
        """Запуск полной проверки здоровья"""
        print(f"🏥 Starting pilot health check for {self.base_url}")
        
        checks = [
            self.check_main_page,
            self.check_api_endpoints,
            self.check_database_connection,
            self.check_cache_connection,
            self.check_celery_workers,
            self.check_static_files,
            self.check_performance,
            self.check_error_rates,
        ]
        
        for check in checks:
            try:
                result = check()
                self.results.append(result)
                
                if result['status'] == 'FAIL':
                    print(f"❌ {check.__name__}: FAILED")
                    self._send_alert(result)
                else:
                    print(f"✅ {check.__name__}: PASSED")
                    
            except Exception as e:
                error_result = {
                    'check': check.__name__,
                    'status': 'ERROR',
                    'error': str(e),
                    'timestamp': datetime.now().isoformat()
                }
                self.results.append(error_result)
                print(f"💥 {check.__name__}: ERROR - {str(e)}")
        
        self.generate_health_report()
        return self.results
    
    def check_api_endpoints(self):
        """Проверка основных API endpoints"""
        endpoints = [
            '/api/products/',
            '/api/categories/',
            '/api/auth/login/',
            '/api/health/',
            '/api/orders/',
        ]
        
        results = {}
        for endpoint in endpoints:
            try:
                start_time = time.time()
                response = requests.get(f"{self.base_url}{endpoint}", timeout=10)
                response_time = time.time() - start_time
                
                results[endpoint] = {
                    'status_code': response.status_code,
                    'response_time': response_time,
                    'success': response.status_code == 200
                }
                
                if response_time > 2.0:
                    results[endpoint]['warning'] = 'Slow response'
                    
            except Exception as e:
                results[endpoint] = {
                    'status_code': 0,
                    'error': str(e),
                    'success': False
                }
        
        failed_endpoints = [ep for ep, res in results.items() if not res['success']]
        
        return {
            'check': 'api_endpoints',
            'status': 'FAIL' if failed_endpoints else 'PASS',
            'details': results,
            'failed_endpoints': failed_endpoints,
            'timestamp': datetime.now().isoformat()
        }
    
    def check_performance(self):
        """Проверка производительности"""
        performance_checks = {}
        
        # Проверка времени ответа главной страницы
        start_time = time.time()
        response = requests.get(self.base_url, timeout=10)
        page_load_time = time.time() - start_time
        
        performance_checks['page_load'] = {
            'time': page_load_time,
            'acceptable': page_load_time < 3.0
        }
        
        # Проверка времени выполнения сложного запроса
        start_time = time.time()
        response = requests.get(f"{self.base_url}/api/products/?search=test", timeout=10)
        search_time = time.time() - start_time
        
        performance_checks['search_query'] = {
            'time': search_time,
            'acceptable': search_time < 2.0
        }
        
        # Анализ результатов
        slow_operations = [op for op, res in performance_checks.items() if not res['acceptable']]
        
        return {
            'check': 'performance',
            'status': 'FAIL' if slow_operations else 'PASS',
            'details': performance_checks,
            'slow_operations': slow_operations,
            'timestamp': datetime.now().isoformat()
        }
    
    def check_error_rates(self):
        """Проверка уровня ошибок"""
        try:
            # Получение статистики ошибок из API
            response = requests.get(f"{self.base_url}/api/feedback/errors/statistics/?days=1")
            
            if response.status_code == 200:
                stats = response.json()
                
                critical_errors = stats.get('unresolved_critical', 0)
                total_errors = stats.get('total_errors', 0)
                
                return {
                    'check': 'error_rates',
                    'status': 'FAIL' if critical_errors > 0 else 'PASS',
                    'details': stats,
                    'critical_errors': critical_errors,
                    'total_errors': total_errors,
                    'timestamp': datetime.now().isoformat()
                }
                
        except Exception as e:
            return {
                'check': 'error_rates',
                'status': 'ERROR',
                'error': str(e),
                'timestamp': datetime.now().isoformat()
            }
    
    def _send_alert(self, check_result):
        """Отправка оповещения о проблеме"""
        try:
            subject = f"🚨 Pilot Health Check Alert: {check_result['check']}"
            
            message = f"""
            Обнаружена проблема в пилотной эксплуатации:
            
            Проверка: {check_result['check']}
            Статус: {check_result['status']}
            Время: {check_result['timestamp']}
            
            Детали:
            {json.dumps(check_result.get('details', {}), indent=2, ensure_ascii=False)}
            
            Ссылка на систему: {self.base_url}
            """
            
            self._send_email(subject, message.strip())
            
        except Exception as e:
            print(f"Failed to send alert: {str(e)}")
    
    def generate_health_report(self):
        """Генерация отчета о здоровье системы"""
        report = {
            'timestamp': datetime.now().isoformat(),
            'base_url': self.base_url,
            'total_checks': len(self.results),
            'passed_checks': sum(1 for r in self.results if r['status'] == 'PASS'),
            'failed_checks': sum(1 for r in self.results if r['status'] == 'FAIL'),
            'error_checks': sum(1 for r in self.results if r['status'] == 'ERROR'),
            'results': self.results
        }
        
        # Сохранение отчета
        with open(f'/var/log/ecommerce/health_report_{datetime.now().strftime("%Y%m%d_%H%M")}.json', 'w') as f:
            json.dump(report, f, indent=2, ensure_ascii=False)
        
        print(f"\n📊 Health Check Report:")
        print(f"✅ Passed: {report['passed_checks']}")
        print(f"❌ Failed: {report['failed_checks']}")
        print(f"💥 Errors: {report['error_checks']}")
        
        return report

if __name__ == "__main__":
    checker = PilotHealthChecker("https://pilot.example.com")
    results = checker.run_full_health_check()
```

### **4.2. Автоматизированные тесты пользовательских сценариев**

```python
# scripts/pilot_user_scenarios.py
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import TimeoutException
import time
import json

class PilotUserScenarioTester:
    """Тестирование пользовательских сценариев в пилотной среде"""
    
    def __init__(self, base_url):
        self.base_url = base_url
        self.setup_driver()
    
    def setup_driver(self):
        """Настройка Selenium WebDriver"""
        options = webdriver.ChromeOptions()
        options.add_argument('--headless')
        options.add_argument('--no-sandbox')
        options.add_argument('--disable-dev-shm-usage')
        
        self.driver = webdriver.Chrome(options=options)
        self.driver.implicitly_wait(10)
    
    def test_complete_purchase_flow(self):
        """Тест полного цикла покупки"""
        scenario_steps = []
        
        try:
            # Шаг 1: Открытие главной страницы
            self.driver.get(self.base_url)
            WebDriverWait(self.driver, 10).until(
                EC.presence_of_element_located((By.TAG_NAME, "body"))
            )
            scenario_steps.append({"step": "homepage_load", "status": "success"})
            
            # Шаг 2: Поиск товара
            search_input = self.driver.find_element(By.CSS_SELECTOR, "input[type='search']")
            search_input.send_keys("test product")
            search_input.submit()
            
            WebDriverWait(self.driver, 10).until(
                EC.presence_of_element_located((By.CLASS_NAME, "product-card"))
            )
            scenario_steps.append({"step": "product_search", "status": "success"})
            
            # Шаг 3: Добавление в корзину
            add_to_cart_buttons = self.driver.find_elements(By.CSS_SELECTOR, ".add-to-cart")
            if add_to_cart_buttons:
                add_to_cart_buttons[0].click()
                
                WebDriverWait(self.driver, 10).until(
                    EC.presence_of_element_located((By.CLASS_NAME, "cart-notification"))
                )
                scenario_steps.append({"step": "add_to_cart", "status": "success"})
            
            # Шаг 4: Переход в корзину
            cart_link = self.driver.find_element(By.CSS_SELECTOR, ".cart-link")
            cart_link.click()
            
            WebDriverWait(self.driver, 10).until(
                EC.presence_of_element_located((By.CLASS_NAME, "cart-items"))
            )
            scenario_steps.append({"step": "cart_page", "status": "success"})
            
            return {
                "scenario": "complete_purchase_flow",
                "status": "success",
                "steps": scenario_steps,
                "timestamp": time.time()
            }
            
        except TimeoutException as e:
            scenario_steps.append({
                "step": "timeout_error", 
                "status": "error",
                "error": str(e)
            })
            return {
                "scenario": "complete_purchase_flow",
                "status": "failed",
                "steps": scenario_steps,
                "error": "Timeout occurred",
                "timestamp": time.time()
            }
        
        except Exception as e:
            scenario_steps.append({
                "step": "unexpected_error",
                "status": "error", 
                "error": str(e)
            })
            return {
                "scenario": "complete_purchase_flow",
                "status": "failed",
                "steps": scenario_steps,
                "error": str(e),
                "timestamp": time.time()
            }
    
    def test_user_registration_flow(self):
        """Тест потока регистрации пользователя"""
        # Реализация теста регистрации...
        pass
    
    def run_all_scenarios(self):
        """Запуск всех пользовательских сценариев"""
        scenarios = [
            self.test_complete_purchase_flow,
            self.test_user_registration_flow,
        ]
        
        results = []
        for scenario in scenarios:
            result = scenario()
            results.append(result)
            
            if result['status'] == 'success':
                print(f"✅ {result['scenario']}: PASSED")
            else:
                print(f"❌ {result['scenario']}: FAILED - {result.get('error', 'Unknown error')}")
        
        # Сохранение результатов
        with open('/var/log/ecommerce/user_scenarios.json', 'w') as f:
            json.dump(results, f, indent=2)
        
        return results
    
    def __del__(self):
        """Завершение работы драйвера"""
        if hasattr(self, 'driver'):
            self.driver.quit()

if __name__ == "__main__":
    tester = PilotUserScenarioTester("https://pilot.example.com")
    results = tester.run_all_scenarios()
```

---

## **5. Система отчетности и дашборды**

### **5.1. Генератор отчетов для опытной эксплуатации**

```python
# scripts/pilot_report_generator.py
from datetime import datetime, timedelta
import json
import pandas as pd
import matplotlib.pyplot as plt
from modules.feedback.services.error_tracking import ErrorTrackingService

class PilotReportGenerator:
    """Генератор отчетов по опытной эксплуатации"""
    
    def generate_weekly_report(self):
        """Генерация еженедельного отчета"""
        
        report_data = {
            'period': 'weekly',
            'generated_at': datetime.now().isoformat(),
            'error_analysis': self._analyze_errors(),
            'performance_metrics': self._get_performance_metrics(),
            'user_feedback': self._get_user_feedback_summary(),
            'system_health': self._get_system_health_status(),
            'recommendations': self._generate_recommendations()
        }
        
        # Генерация визуализаций
        self._generate_charts(report_data)
        
        # Сохранение отчета
        report_file = f"/var/log/ecommerce/pilot_weekly_report_{datetime.now().strftime('%Y%m%d')}.json"
        with open(report_file, 'w') as f:
            json.dump(report_data, f, indent=2, ensure_ascii=False)
        
        return report_data
    
    def _analyze_errors(self):
        """Анализ ошибок за период"""
        
        error_stats = ErrorTrackingService.get_error_statistics(7)
        
        analysis = {
            'total_errors': error_stats['total_errors'],
            'error_trend': self._calculate_error_trend(),
            'top_issues': list(error_stats['by_category'])[:5],
            'critical_issues': error_stats['unresolved_critical'],
            'most_affected_modules': list(error_stats['by_module'])[:3]
        }
        
        return analysis
    
    def _get_performance_metrics(self):
        """Сбор метрик производительности"""
        
        # Здесь можно добавить сбор метрик из мониторинговой системы
        performance_data = {
            'average_response_time': self._get_avg_response_time(),
            'p95_response_time': self._get_p95_response_time(),
            'throughput': self._get_throughput(),
            'error_rate': self._get_error_rate(),
            'slow_queries': self._get_slow_queries_count()
        }
        
        return performance_data
    
    def _generate_recommendations(self):
        """Генерация рекомендаций по исправлению"""
        
        recommendations = []
        
        error_stats = ErrorTrackingService.get_error_statistics(7)
        
        # Рекомендации на основе анализа ошибок
        for category in error_stats['by_category']:
            if category['count'] > 10:  # Порог для рекомендаций
                recommendations.append({
                    'type': 'high_priority_fix',
                    'module': category['category'],
                    'description': f'Высокий уровень ошибок в модуле {category["category"]}',
                    'priority': 'high'
                })
        
        # Рекомендации по производительности
        performance_data = self._get_performance_metrics()
        if performance_data['p95_response_time'] > 3.0:
            recommendations.append({
                'type': 'performance_optimization',
                'description': 'Высокое время ответа для 95% запросов',
                'priority': 'medium'
            })
        
        return recommendations
    
    def _generate_charts(self, report_data):
        """Генерация графиков для отчета"""
        
        # График распределения ошибок по категориям
        categories = [item['category'] for item in report_data['error_analysis']['top_issues']]
        counts = [item['count'] for item in report_data['error_analysis']['top_issues']]
        
        plt.figure(figsize=(10, 6))
        plt.bar(categories, counts)
        plt.title('Распределение ошибок по категориям')
        plt.xticks(rotation=45)
        plt.tight_layout()
        plt.savefig('/var/log/ecommerce/error_categories.png')
        plt.close()
```

### **5.2. Дашборд для мониторинга опытной эксплуатации**

```python
# modules/feedback/views/dashboard.py
from django.views.generic import TemplateView
from django.utils import timezone
from django.db.models import Count, Q
from django.contrib.auth.mixins import LoginRequiredMixin
from ..models import PilotErrorReport, SystemMetric

class PilotDashboardView(LoginRequiredMixin, TemplateView):
    """Дашборд для мониторинга опытной эксплуатации"""
    
    template_name = 'feedback/pilot_dashboard.html'
    
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        
        # Статистика ошибок
        context['error_stats'] = self._get_error_statistics()
        
        # Метрики производительности
        context['performance_metrics'] = self._get_performance_metrics()
        
        # Последние ошибки
        context['recent_errors'] = PilotErrorReport.objects.filter(
            status__in=['new', 'investigating', 'confirmed']
        ).order_by('-created_at')[:10]
        
        # Тренды
        context['error_trend'] = self._get_error_trend()
        
        return context
    
    def _get_error_statistics(self):
        """Получение статистики ошибок"""
        
        today = timezone.now().date()
        week_ago = today - timezone.timedelta(days=7)
        
        stats = {
            'total_errors_week': PilotErrorReport.objects.filter(
                created_at__gte=week_ago
            ).count(),
            
            'critical_errors': PilotErrorReport.objects.filter(
                severity='critical',
                status__in=['new', 'investigating', 'confirmed']
            ).count(),
            
            'errors_by_status': PilotErrorReport.objects.filter(
                created_at__gte=week_ago
            ).values('status').annotate(
                count=Count('id')
            ),
            
            'top_modules': PilotErrorReport.objects.filter(
                created_at__gte=week_ago
            ).values('module').annotate(
                count=Count('id')
            ).order_by('-count')[:5]
        }
        
        return stats
```

---

## **6. Процесс фиксации и исправления ошибок**

### **6.1. Workflow обработки ошибок**

```python
# modules/feedback/services/error_workflow.py
from django.core.mail import send_mail
from django.template.loader import render_to_string
from ..models import PilotErrorReport

class ErrorWorkflowService:
    """Сервис для управления workflow обработки ошибок"""
    
    @classmethod
    def assign_error(cls, error_report, assigned_to, comment=None):
        """Назначение ошибки на разработчика"""
        
        error_report.assigned_to = assigned_to
        error_report.status = 'in_progress'
        error_report.save()
        
        if comment:
            error_report.comments.create(
                author=assigned_to,
                content=comment,
                is_technical_note=True
            )
        
        # Уведомление разработчика
        cls._send_assignment_notification(error_report, assigned_to)
        
        return error_report
    
    @classmethod
    def resolve_error(cls, error_report, resolved_by, solution_details):
        """Решение ошибки"""
        
        error_report.status = 'resolved'
        error_report.resolved_at = timezone.now()
        error_report.assigned_to = resolved_by
        error_report.save()
        
        # Добавление комментария с решением
        error_report.comments.create(
            author=resolved_by,
            content=f"Ошибка исправлена:\n{solution_details}",
            is_technical_note=True
        )
        
        # Уведомление пользователя (если указан email)
        if error_report.user_email:
            cls._send_resolution_notification(error_report)
        
        return error_report
    
    @classmethod
    def _send_assignment_notification(cls, error_report, assigned_to):
        """Уведомление о назначении ошибки"""
        
        subject = f"🔧 На вас назначена ошибка: {error_report.title}"
        
        message = render_to_string('feedback/email/error_assigned.txt', {
            'error_report': error_report,
            'assigned_to': assigned_to,
        })
        
        send_mail(
            subject=subject,
            message=message,
            from_email='noreply@example.com',
            recipient_list=[assigned_to.email],
            fail_silently=True,
        )
```

### **6.2. Интеграция с системой контроля версий**

```python
# scripts/error_to_issue_integration.py
import requests
import json
from datetime import datetime

class GitHubIntegration:
    """Интеграция с GitHub для создания issues из ошибок"""
    
    def __init__(self, token, repo):
        self.token = token
        self.repo = repo
        self.headers = {
            'Authorization': f'token {token}',
            'Accept': 'application/vnd.github.v3+json'
        }
    
    def create_issue_from_error(self, error_report):
        """Создание GitHub issue из отчета об ошибке"""
        
        issue_data = {
            'title': f"[PILOT] {error_report.title}",
            'body': self._format_issue_body(error_report),
            'labels': [
                'pilot',
                f'severity:{error_report.severity}',
                f'module:{error_report.module}',
                f'category:{error_report.category}'
            ],
            'assignees': self._get_assignees(error_report.module)
        }
        
        response = requests.post(
            f'https://api.github.com/repos/{self.repo}/issues',
            headers=self.headers,
            json=issue_data
        )
        
        if response.status_code == 201:
            issue_data = response.json()
            
            # Сохраняем ссылку на issue в ошибке
            error_report.metadata = {
                'github_issue_url': issue_data['html_url'],
                'github_issue_number': issue_data['number']
            }
            error_report.save()
            
            return issue_data
        else:
            raise Exception(f"Failed to create issue: {response.text}")
    
    def _format_issue_body(self, error_report):
        """Форматирование тела issue"""
        
        return f"""
## Описание ошибки

{error_report.description}

## Шаги воспроизведения

{error_report.steps_to_reproduce or 'Не указаны'}

## Ожидаемое поведение

{error_report.expected_behavior}

## Фактическое поведение

{error_report.actual_behavior}

## Техническая информация

- **Модуль**: {error_report.module}
- **Категория**: {error_report.get_category_display()}
- **Серьезность**: {error_report.get_severity_display()}
- **URL**: {error_report.url or 'Не указан'}
- **Браузер**: {error_report.browser or 'Не указан'}
- **ОС**: {error_report.operating_system or 'Не указана'}

## Пользователь

- **Email**: {error_report.user_email or 'Не указан'}
- **ID отчета**: {error_report.id}

## Дополнительная информация

Ошибка обнаружена в режиме опытной эксплуатации.
"""
```

Данная система обеспечивает комплексный подход к тестированию в условиях опытной эксплуатации с полным циклом выявления, фиксации, анализа и исправления ошибок кодирования.
