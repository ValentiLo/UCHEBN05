# **ПМ05. Реализация алгоритмов обработки числовых данных для интернет-магазина**

## **1. Алгоритмы анализа продаж и цен**

### **1.1. Алгоритм расчета динамики продаж**

```python
# modules/analytics/services/sales_analysis.py
import numpy as np
import pandas as pd
from datetime import datetime, timedelta
from django.db.models import Sum, Count, Avg
from collections import defaultdict
from typing import Dict, List, Tuple

class SalesAnalysisService:
    
    @staticmethod
    def calculate_sales_trends(period_days: int = 30) -> Dict:
        """
        Расчет трендов продаж за указанный период
        """
        from ..models import Order, OrderItem
        
        end_date = datetime.now()
        start_date = end_date - timedelta(days=period_days)
        
        # Получение данных о продажах по дням
        daily_sales = Order.objects.filter(
            created_at__range=[start_date, end_date],
            status__in=['delivered', 'shipped']
        ).extra({
            'date': "DATE(created_at)"
        }).values('date').annotate(
            total_sales=Sum('total'),
            order_count=Count('id'),
            avg_order_value=Avg('total')
        ).order_by('date')
        
        # Преобразование в pandas DataFrame для анализа
        df = pd.DataFrame(list(daily_sales))
        if df.empty:
            return {
                'trend': 'stable',
                'growth_rate': 0,
                'prediction': 0
            }
        
        df['date'] = pd.to_datetime(df['date'])
        df = df.set_index('date')
        
        # Расчет тренда с использованием линейной регрессии
        trend_data = SalesAnalysisService._calculate_linear_trend(df['total_sales'])
        
        # Прогнозирование на следующий период
        prediction = SalesAnalysisService._predict_next_period(df['total_sales'])
        
        return {
            'trend': trend_data['direction'],
            'growth_rate': trend_data['growth_rate'],
            'prediction': prediction,
            'daily_data': df.to_dict('records')
        }
    
    @staticmethod
    def _calculate_linear_trend(series: pd.Series) -> Dict:
        """
        Расчет линейного тренда временного ряда
        """
        from sklearn.linear_model import LinearRegression
        
        # Подготовка данных для регрессии
        X = np.array(range(len(series))).reshape(-1, 1)
        y = series.values
        
        # Обучение модели
        model = LinearRegression()
        model.fit(X, y)
        
        # Расчет углового коэффициента (наклона)
        slope = model.coef_[0]
        
        # Определение направления тренда
        if slope > 0:
            direction = 'upward'
        elif slope < 0:
            direction = 'downward'
        else:
            direction = 'stable'
        
        # Расчет темпа роста (%)
        first_value = y[0]
        last_value = y[-1]
        growth_rate = ((last_value - first_value) / first_value * 100) if first_value != 0 else 0
        
        return {
            'direction': direction,
            'slope': slope,
            'growth_rate': growth_rate,
            'r_squared': model.score(X, y)
        }
    
    @staticmethod
    def _predict_next_period(series: pd.Series, periods: int = 7) -> float:
        """
        Прогнозирование продаж на следующий период с использованием скользящего среднего
        """
        if len(series) < 3:
            return float(series.mean()) if not series.empty else 0
        
        # Использование взвешенного скользящего среднего
        weights = np.array([0.1, 0.3, 0.6])  # Больший вес для последних точек
        recent_data = series.tail(3).values
        
        if len(recent_data) == 3:
            prediction = np.average(recent_data, weights=weights)
        else:
            prediction = recent_data.mean()
        
        return float(prediction)
```

### **1.2. Алгоритм оптимизации цен**

```python
# modules/pricing/services/price_optimization.py
import numpy as np
from scipy.optimize import minimize_scalar
from typing import Dict, List

class PriceOptimizationService:
    
    @staticmethod
    def optimize_product_price(product_id: str, cost_price: float, 
                             current_price: float, elasticity: float = -2.0) -> Dict:
        """
        Оптимизация цены товара на основе ценовой эластичности
        
        Args:
            product_id: ID товара
            cost_price: Себестоимость
            current_price: Текущая цена
            elasticity: Коэффициент ценовой эластичности (по умолчанию -2.0)
        """
        
        def profit_function(price):
            """Функция прибыли для оптимизации"""
            # Модель спроса на основе ценовой эластичности
            demand = PriceOptimizationService._calculate_demand(
                current_price, price, elasticity
            )
            
            # Расчет прибыли
            revenue = price * demand
            total_cost = cost_price * demand
            profit = revenue - total_cost
            
            return -profit  # Минимизируем отрицательную прибыль
        
        # Оптимизация цены
        result = minimize_scalar(
            profit_function,
            bounds=(cost_price * 1.1, cost_price * 3),  # Цена от 110% до 300% себестоимости
            method='bounded'
        )
        
        optimal_price = result.x
        max_profit = -result.fun
        
        return {
            'current_price': current_price,
            'optimal_price': round(optimal_price, 2),
            'max_profit': round(max_profit, 2),
            'price_change_percent': round(((optimal_price - current_price) / current_price * 100), 1),
            'success': result.success
        }
    
    @staticmethod
    def _calculate_demand(base_price: float, new_price: float, elasticity: float) -> float:
        """
        Расчет спроса на основе ценовой эластичности
        """
        price_ratio = new_price / base_price
        demand_change = price_ratio ** elasticity  # Формула ценовой эластичности
        base_demand = 100  # Базовый спрос при текущей цене
        
        return base_demand * demand_change
    
    @staticmethod
    def calculate_price_elasticity(product_id: str, price_changes: List[float], 
                                 sales_changes: List[float]) -> float:
        """
        Расчет коэффициента ценовой эластичности на исторических данных
        """
        if len(price_changes) != len(sales_changes) or len(price_changes) < 2:
            return -2.0  # Значение по умолчанию
        
        # Преобразование в проценты изменений
        price_pct_changes = np.array([(p - price_changes[0]) / price_changes[0] * 100 
                                    for p in price_changes])
        sales_pct_changes = np.array([(s - sales_changes[0]) / sales_changes[0] * 100 
                                    for s in sales_changes])
        
        # Расчет эластичности как отношение процентных изменений
        # Исключаем деление на ноль и бесконечные значения
        valid_indices = np.where(price_pct_changes != 0)[0]
        
        if len(valid_indices) == 0:
            return -2.0
        
        elasticities = (sales_pct_changes[valid_indices] / 
                       price_pct_changes[valid_indices])
        
        return float(np.median(elasticities))
```

---

## **2. Алгоритмы управления запасами**

### **2.1. Алгоритм оптимизации уровня запасов**

```python
# modules/inventory/services/stock_optimization.py
import numpy as np
from scipy import stats
from typing import Dict, List

class StockOptimizationService:
    
    @staticmethod
    def calculate_optimal_stock_level(product_id: str, 
                                    demand_history: List[float],
                                    lead_time: int,
                                    service_level: float = 0.95) -> Dict:
        """
        Расчет оптимального уровня запасов методом Newsvendor
        с учетом уровня сервиса
        
        Args:
            product_id: ID товара
            demand_history: История спроса
            lead_time: Время поставки в днях
            service_level: Желаемый уровень сервиса (0-1)
        """
        
        if not demand_history:
            return {
                'reorder_point': 0,
                'safety_stock': 0,
                'optimal_order_quantity': 0
            }
        
        # Статистические параметры спроса
        demand_mean = np.mean(demand_history)
        demand_std = np.std(demand_history)
        
        # Расчет страхового запаса
        z_score = stats.norm.ppf(service_level)  # Z-score для уровня сервиса
        safety_stock = z_score * demand_std * np.sqrt(lead_time)
        
        # Точка перезаказа
        reorder_point = (demand_mean * lead_time) + safety_stock
        
        # Оптимальный размер заказа (EOQ - Economic Order Quantity)
        optimal_order_quantity = StockOptimizationService._calculate_eoq(
            demand_mean, cost_per_order=50, holding_cost_rate=0.25
        )
        
        return {
            'reorder_point': round(reorder_point),
            'safety_stock': round(safety_stock),
            'optimal_order_quantity': round(optimal_order_quantity),
            'current_service_level': StockOptimizationService._calculate_current_service_level(
                demand_history, lead_time
            ),
            'z_score': round(z_score, 3)
        }
    
    @staticmethod
    def _calculate_eoq(annual_demand: float, cost_per_order: float, 
                      holding_cost_rate: float, unit_cost: float = 100) -> float:
        """
        Расчет экономичного размера заказа (EOQ formula)
        """
        holding_cost_per_unit = unit_cost * holding_cost_rate
        
        if holding_cost_per_unit == 0:
            return annual_demand
        
        eoq = np.sqrt((2 * annual_demand * cost_per_order) / holding_cost_per_unit)
        return eoq
    
    @staticmethod
    def _calculate_current_service_level(demand_history: List[float], 
                                       lead_time: int) -> float:
        """
        Расчет текущего уровня сервиса
        """
        if len(demand_history) < lead_time + 1:
            return 0.0
        
        stockout_events = 0
        total_periods = len(demand_history) - lead_time
        
        for i in range(total_periods):
            demand_during_lead_time = sum(demand_history[i:i + lead_time])
            available_stock = demand_history[i] * 2  # Упрощенное предположение
            
            if demand_during_lead_time > available_stock:
                stockout_events += 1
        
        service_level = 1 - (stockout_events / total_periods) if total_periods > 0 else 0
        return round(service_level, 3)
```

### **2.2. Алгоритм прогнозирования спроса**

```python
# modules/forecasting/services/demand_forecasting.py
import numpy as np
import pandas as pd
from sklearn.linear_model import LinearRegression
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_absolute_error, mean_squared_error
from typing import Dict, List, Tuple

class DemandForecastingService:
    
    @staticmethod
    def forecast_demand(product_id: str, historical_data: List[Dict], 
                       forecast_periods: int = 30) -> Dict:
        """
        Прогнозирование спроса с использованием нескольких методов
        """
        if len(historical_data) < 30:
            return DemandForecastingService._simple_forecast(historical_data, forecast_periods)
        
        # Подготовка данных
        df = pd.DataFrame(historical_data)
        df['date'] = pd.to_datetime(df['date'])
        df = df.set_index('date')
        
        # Создание признаков для машинного обучения
        features = DemandForecastingService._create_features(df)
        
        # Прогнозирование разными методами
        linear_forecast = DemandForecastingService._linear_regression_forecast(
            features, forecast_periods
        )
        moving_avg_forecast = DemandForecastingService._moving_average_forecast(
            df['demand'], forecast_periods
        )
        seasonal_forecast = DemandForecastingService._seasonal_forecast(
            df['demand'], forecast_periods
        )
        
        # Ансамблирование прогнозов
        ensemble_forecast = DemandForecastingService._ensemble_forecasts([
            linear_forecast, moving_avg_forecast, seasonal_forecast
        ])
        
        # Оценка точности на исторических данных
        accuracy = DemandForecastingService._calculate_accuracy(
            df['demand'], linear_forecast[:len(df)]
        )
        
        return {
            'forecast': ensemble_forecast,
            'accuracy': accuracy,
            'confidence_interval': DemandForecastingService._calculate_confidence_interval(
                ensemble_forecast, df['demand'].std()
            ),
            'method_used': 'ensemble'
        }
    
    @staticmethod
    def _create_features(df: pd.DataFrame) -> pd.DataFrame:
        """Создание признаков для прогнозирования"""
        features = df.copy()
        
        # Временные признаки
        features['day_of_week'] = features.index.dayofweek
        features['day_of_month'] = features.index.day
        features['month'] = features.index.month
        features['quarter'] = features.index.quarter
        
        # Лаговые признаки
        for lag in [1, 7, 30]:
            features[f'demand_lag_{lag}'] = features['demand'].shift(lag)
        
        # Скользящие средние
        for window in [7, 30]:
            features[f'demand_ma_{window}'] = features['demand'].rolling(window).mean()
        
        return features.dropna()
    
    @staticmethod
    def _linear_regression_forecast(features: pd.DataFrame, periods: int) -> List[float]:
        """Прогнозирование с помощью линейной регрессии"""
        X = features.drop('demand', axis=1)
        y = features['demand']
        
        model = LinearRegression()
        model.fit(X, y)
        
        # Создание будущих признаков для прогноза
        last_date = features.index[-1]
        future_dates = pd.date_range(last_date + pd.Timedelta(days=1), 
                                   periods=periods, freq='D')
        
        future_features = []
        for i, date in enumerate(future_dates):
            feature_row = {
                'day_of_week': date.dayofweek,
                'day_of_month': date.day,
                'month': date.month,
                'quarter': date.quarter,
                'demand_lag_1': features['demand'].iloc[-1],
                'demand_lag_7': features['demand'].iloc[-7] if len(features) >= 7 else features['demand'].iloc[-1],
                'demand_lag_30': features['demand'].iloc[-30] if len(features) >= 30 else features['demand'].iloc[-1],
                'demand_ma_7': features['demand'].tail(7).mean(),
                'demand_ma_30': features['demand'].tail(30).mean()
            }
            future_features.append(feature_row)
        
        future_df = pd.DataFrame(future_features)
        forecast = model.predict(future_df)
        
        return forecast.tolist()
    
    @staticmethod
    def _moving_average_forecast(series: pd.Series, periods: int, 
                               window: int = 7) -> List[float]:
        """Прогнозирование методом скользящего среднего"""
        if len(series) < window:
            return [series.mean()] * periods
        
        last_ma = series.tail(window).mean()
        return [last_ma] * periods
    
    @staticmethod
    def _seasonal_forecast(series: pd.Series, periods: int) -> List[float]:
        """Прогнозирование с учетом сезонности"""
        if len(series) < 30:
            return [series.mean()] * periods
        
        # Простой метод сезонного прогнозирования
        seasonal_pattern = []
        for i in range(7):  # Недельная сезонность
            day_data = series[series.index.dayofweek == i]
            if len(day_data) > 0:
                seasonal_pattern.append(day_data.mean())
            else:
                seasonal_pattern.append(series.mean())
        
        forecast = []
        last_date = series.index[-1]
        for i in range(periods):
            day_of_week = (last_date.dayofweek + i + 1) % 7
            forecast.append(seasonal_pattern[day_of_week])
        
        return forecast
    
    @staticmethod
    def _ensemble_forecasts(forecasts: List[List[float]]) -> List[float]:
        """Ансамблирование прогнозов взвешенным средним"""
        weights = [0.4, 0.3, 0.3]  # Веса для разных методов
        ensemble = []
        
        for i in range(len(forecasts[0])):
            weighted_sum = 0
            for j, forecast in enumerate(forecasts):
                weighted_sum += forecast[i] * weights[j]
            ensemble.append(weighted_sum)
        
        return ensemble
    
    @staticmethod
    def _calculate_accuracy(actual: pd.Series, predicted: List[float]) -> Dict:
        """Расчет метрик точности прогноза"""
        if len(actual) != len(predicted):
            return {}
        
        mae = mean_absolute_error(actual, predicted)
        mse = mean_squared_error(actual, predicted)
        rmse = np.sqrt(mse)
        
        # Mean Absolute Percentage Error (MAPE)
        mape = np.mean(np.abs((actual - predicted) / actual)) * 100
        
        return {
            'mae': round(mae, 2),
            'rmse': round(rmse, 2),
            'mape': round(mape, 2)
        }
    
    @staticmethod
    def _calculate_confidence_interval(forecast: List[float], 
                                     std_dev: float, 
                                     confidence: float = 0.95) -> List[Tuple]:
        """Расчет доверительного интервала прогноза"""
        z_score = 1.96  # для 95% доверительного интервала
        
        intervals = []
        for point_forecast in forecast:
            margin_of_error = z_score * std_dev
            lower = max(0, point_forecast - margin_of_error)
            upper = point_forecast + margin_of_error
            intervals.append((round(lower, 2), round(upper, 2)))
        
        return intervals
```

---

## **3. Алгоритмы анализа клиентов**

### **3.1. Алгоритм сегментации клиентов (RFM-анализ)**

```python
# modules/analytics/services/customer_segmentation.py
import pandas as pd
import numpy as np
from sklearn.cluster import KMeans
from sklearn.preprocessing import StandardScaler
from typing import Dict, List

class CustomerSegmentationService:
    
    @staticmethod
    def perform_rfm_analysis(customer_data: List[Dict]) -> Dict:
        """
        RFM-анализ клиентов (Recency, Frequency, Monetary)
        """
        df = pd.DataFrame(customer_data)
        
        # Расчет RFM метрик
        current_date = pd.Timestamp.now()
        
        rfm = df.groupby('customer_id').agg({
            'order_date': lambda x: (current_date - x.max()).days,  # Recency
            'order_id': 'count',  # Frequency
            'order_value': 'sum'   # Monetary
        }).reset_index()
        
        rfm.columns = ['customer_id', 'recency', 'frequency', 'monetary']
        
        # Квантильная сегментация
        rfm['r_score'] = pd.qcut(rfm['recency'], 5, labels=[5, 4, 3, 2, 1])
        rfm['f_score'] = pd.qcut(rfm['frequency'], 5, labels=[1, 2, 3, 4, 5])
        rfm['m_score'] = pd.qcut(rfm['monetary'], 5, labels=[1, 2, 3, 4, 5])
        
        # RFM сегмент
        rfm['rfm_score'] = rfm['r_score'].astype(str) + rfm['f_score'].astype(str) + rfm['m_score'].astype(str)
        
        # Определение сегментов
        rfm['segment'] = rfm.apply(CustomerSegmentationService._assign_segment, axis=1)
        
        return {
            'segments': rfm.to_dict('records'),
            'segment_summary': rfm['segment'].value_counts().to_dict(),
            'avg_monetary_by_segment': rfm.groupby('segment')['monetary'].mean().to_dict()
        }
    
    @staticmethod
    def _assign_segment(row) -> str:
        """Назначение сегмента на основе RFM scores"""
        r_score = int(row['r_score'])
        f_score = int(row['f_score'])
        m_score = int(row['m_score'])
        
        if r_score >= 4 and f_score >= 4 and m_score >= 4:
            return "Champions"
        elif r_score >= 3 and f_score >= 3 and m_score >= 3:
            return "Loyal Customers"
        elif r_score >= 4 and f_score >= 2:
            return "Potential Loyalists"
        elif r_score >= 3 and f_score >= 3:
            return "Need Attention"
        elif r_score >= 2 and f_score >= 2:
            return "At Risk"
        else:
            return "Lost Customers"
    
    @staticmethod
    def calculate_customer_lifetime_value(customer_data: List[Dict], 
                                        discount_rate: float = 0.1) -> Dict:
        """
        Расчет пожизненной ценности клиента (LTV)
        """
        df = pd.DataFrame(customer_data)
        
        # Группировка по клиентам
        customer_metrics = df.groupby('customer_id').agg({
            'order_value': ['sum', 'mean', 'count'],
            'order_date': ['min', 'max']
        }).reset_index()
        
        customer_metrics.columns = ['customer_id', 'total_revenue', 'avg_order_value', 
                                  'order_count', 'first_order', 'last_order']
        
        # Расчет LTV
        avg_order_value = customer_metrics['avg_order_value'].mean()
        purchase_frequency = customer_metrics['order_count'].sum() / len(customer_metrics)
        
        # Предполагаемая продолжительность жизни клиента (в месяцах)
        customer_lifespan = 36  # 3 года в среднем
        
        # Формула LTV
        ltv = (avg_order_value * purchase_frequency * customer_lifespan) / (1 + discount_rate)
        
        return {
            'avg_ltv': round(ltv, 2),
            'ltv_by_customer': customer_metrics.set_index('customer_id')['total_revenue'].to_dict(),
            'top_customers': customer_metrics.nlargest(10, 'total_revenue').to_dict('records')
        }
```

---

## **4. Алгоритмы финансового анализа**

### **4.1. Алгоритм расчета ключевых финансовых показателей**

```python
# modules/analytics/services/financial_analysis.py
import numpy as np
import pandas as pd
from typing import Dict, List

class FinancialAnalysisService:
    
    @staticmethod
    def calculate_financial_metrics(sales_data: List[Dict], 
                                  cost_data: List[Dict]) -> Dict:
        """
        Расчет ключевых финансовых показателей
        """
        sales_df = pd.DataFrame(sales_data)
        cost_df = pd.DataFrame(cost_data)
        
        # Основные метрики
        total_revenue = sales_df['amount'].sum()
        total_cost = cost_df['amount'].sum()
        gross_profit = total_revenue - total_cost
        gross_margin = (gross_profit / total_revenue * 100) if total_revenue > 0 else 0
        
        # Расчет операционных показателей
        operational_metrics = FinancialAnalysisService._calculate_operational_metrics(
            sales_df, cost_df
        )
        
        # Анализ рентабельности
        profitability_metrics = FinancialAnalysisService._calculate_profitability_metrics(
            gross_profit, total_revenue, operational_metrics['operating_costs']
        )
        
        # Анализ эффективности
        efficiency_metrics = FinancialAnalysisService._calculate_efficiency_metrics(sales_df)
        
        return {
            'revenue_metrics': {
                'total_revenue': round(total_revenue, 2),
                'gross_profit': round(gross_profit, 2),
                'gross_margin': round(gross_margin, 2)
            },
            'operational_metrics': operational_metrics,
            'profitability_metrics': profitability_metrics,
            'efficiency_metrics': efficiency_metrics
        }
    
    @staticmethod
    def _calculate_operational_metrics(sales_df: pd.DataFrame, 
                                     cost_df: pd.DataFrame) -> Dict:
        """Расчет операционных показателей"""
        operating_costs = cost_df[cost_df['type'] == 'operating']['amount'].sum()
        cogs = cost_df[cost_df['type'] == 'cogs']['amount'].sum()
        
        # Расчет точки безубыточности
        fixed_costs = cost_df[cost_df['type'] == 'fixed']['amount'].sum()
        variable_costs_ratio = cost_df[cost_df['type'] == 'variable']['amount'].sum() / sales_df['amount'].sum()
        
        if variable_costs_ratio < 1:
            break_even_point = fixed_costs / (1 - variable_costs_ratio)
        else:
            break_even_point = float('inf')
        
        return {
            'operating_costs': round(operating_costs, 2),
            'cogs': round(cogs, 2),
            'fixed_costs': round(fixed_costs, 2),
            'variable_costs_ratio': round(variable_costs_ratio, 3),
            'break_even_point': round(break_even_point, 2)
        }
    
    @staticmethod
    def _calculate_profitability_metrics(gross_profit: float, 
                                       total_revenue: float,
                                       operating_costs: float) -> Dict:
        """Расчет показателей рентабельности"""
        operating_profit = gross_profit - operating_costs
        operating_margin = (operating_profit / total_revenue * 100) if total_revenue > 0 else 0
        net_profit_margin = (operating_profit / total_revenue * 100) if total_revenue > 0 else 0
        
        # ROI (Return on Investment)
        total_investment = operating_costs * 12  # Упрощенный расчет
        roi = (operating_profit / total_investment * 100) if total_investment > 0 else 0
        
        return {
            'operating_profit': round(operating_profit, 2),
            'operating_margin': round(operating_margin, 2),
            'net_profit_margin': round(net_profit_margin, 2),
            'roi': round(roi, 2)
        }
    
    @staticmethod
    def _calculate_efficiency_metrics(sales_df: pd.DataFrame) -> Dict:
        """Расчет показателей эффективности"""
        # Оборачиваемость запасов
        avg_inventory = sales_df['inventory_value'].mean()
        cogs = sales_df['cogs'].sum()
        
        if avg_inventory > 0:
            inventory_turnover = cogs / avg_inventory
        else:
            inventory_turnover = 0
        
        # Оборачиваемость дебиторской задолженности
        avg_receivables = sales_df['receivables'].mean()
        
        if avg_receivables > 0:
            receivables_turnover = sales_df['amount'].sum() / avg_receivables
        else:
            receivables_turnover = 0
        
        return {
            'inventory_turnover': round(inventory_turnover, 2),
            'receivables_turnover': round(receivables_turnover, 2),
            'asset_turnover': round(sales_df['amount'].sum() / sales_df['total_assets'].mean(), 2)
        }
```

---

## **5. Интеграция алгоритмов в систему**

### **5.1. API endpoints для числового анализа**

```python
# modules/analytics/api/views.py
from rest_framework.decorators import api_view
from rest_framework.response import Response
from ..services.sales_analysis import SalesAnalysisService
from ..services.demand_forecasting import DemandForecastingService
from ..services.customer_segmentation import CustomerSegmentationService

@api_view(['GET'])
def sales_trends(request):
    """API для получения трендов продаж"""
    period = int(request.GET.get('period', 30))
    
    trends = SalesAnalysisService.calculate_sales_trends(period)
    
    return Response({
        'success': True,
        'data': trends
    })

@api_view(['POST'])
def demand_forecast(request):
    """API для прогнозирования спроса"""
    product_id = request.data.get('product_id')
    historical_data = request.data.get('historical_data', [])
    periods = int(request.data.get('periods', 30))
    
    forecast = DemandForecastingService.forecast_demand(
        product_id, historical_data, periods
    )
    
    return Response({
        'success': True,
        'forecast': forecast
    })

@api_view(['GET'])
def customer_analytics(request):
    """API для аналитики клиентов"""
    customer_data = get_customer_data()  # Функция для получения данных клиентов
    
    rfm_analysis = CustomerSegmentationService.perform_rfm_analysis(customer_data)
    ltv_analysis = CustomerSegmentationService.calculate_customer_lifetime_value(customer_data)
    
    return Response({
        'success': True,
        'rfm_analysis': rfm_analysis,
        'ltv_analysis': ltv_analysis
    })
```

### **5.2. Периодические задачи для анализа**

```python
# core/tasks/analytics_tasks.py
from celery import shared_task
from modules.analytics.services.sales_analysis import SalesAnalysisService
from modules.forecasting.services.demand_forecasting import DemandForecastingService

@shared_task
def update_sales_analytics():
    """Ежедневное обновление аналитики продаж"""
    trends = SalesAnalysisService.calculate_sales_trends(30)
    
    # Сохранение результатов в базу данных
    save_analytics_results('sales_trends', trends)
    
    return f"Sales analytics updated: {trends['trend']}"

@shared_task
def update_demand_forecasts():
    """Еженедельное обновление прогнозов спроса"""
    products = get_all_products()  # Функция для получения всех товаров
    
    for product in products:
        historical_data = get_product_sales_history(product.id)
        forecast = DemandForecastingService.forecast_demand(
            product.id, historical_data, 30
        )
        
        save_forecast_results(product.id, forecast)
    
    return f"Updated forecasts for {len(products)} products"
```

---

## **6. Тестирование алгоритмов**

### **6.1. Юнит-тесты для числовых алгоритмов**

```python
# tests/test_financial_algorithms.py
import pytest
import numpy as np
from modules.analytics.services.financial_analysis import FinancialAnalysisService

class TestFinancialAlgorithms:
    
    def test_profitability_calculation(self):
        """Тест расчета показателей рентабельности"""
        sales_data = [
            {'amount': 1000, 'type': 'sale'},
            {'amount': 1500, 'type': 'sale'}
        ]
        
        cost_data = [
            {'amount': 500, 'type': 'cogs'},
            {'amount': 200, 'type': 'operating'}
        ]
        
        result = FinancialAnalysisService.calculate_financial_metrics(
            sales_data, cost_data
        )
        
        assert result['revenue_metrics']['total_revenue'] == 2500
        assert result['revenue_metrics']['gross_profit'] == 2000
        assert result['revenue_metrics']['gross_margin'] == 80.0
    
    def test_break_even_calculation(self):
        """Тест расчета точки безубыточности"""
        # Тестовые данные с известной точкой безубыточности
        sales_data = [{'amount': 100}]
        cost_data = [
            {'amount': 500, 'type': 'fixed'},
            {'amount': 50, 'type': 'variable'}  # 50% переменные затраты
        ]
        
        result = FinancialAnalysisService.calculate_financial_metrics(
            sales_data, cost_data
        )
        
        # Точка безубыточности = 500 / (1 - 0.5) = 1000
        assert result['operational_metrics']['break_even_point'] == 1000
```

Реализованные алгоритмы предоставляют:

1. **Точные прогнозы** спроса на основе исторических данных
2. **Оптимизацию цен** для максимизации прибыли
3. **Эффективное управление запасами** с учетом спроса
4. **Глубокую аналитику клиентов** для персонализации
5. **Комплексный финансовый анализ** для принятия решений

Все алгоритмы оптимизированы для работы с большими объемами данных и могут масштабироваться по мере роста интернет-магазина.
