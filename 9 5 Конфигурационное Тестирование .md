# **ПМ05. Конфигурационное тестирование интернет-магазина**

## **1. Стратегия конфигурационного тестирования**

### **1.1. Матрица тестовых конфигураций**

```yaml
# test_configurations/matrix.yml
test_matrix:
  backend:
    python_versions: ["3.8", "3.9", "3.10", "3.11"]
    django_versions: ["4.2", "5.0"]
    databases: 
      - postgresql_13
      - postgresql_14
      - postgresql_15
    cache_backends: ["redis_6", "redis_7", "memcached"]
    
  frontend:
    browsers: 
      desktop:
        - "chrome_120"
        - "chrome_121"
        - "firefox_115"
        - "firefox_116"
        - "safari_16"
        - "safari_17"
      mobile:
        - "chrome_mobile_120"
        - "safari_ios_16"
        - "safari_ios_17"
    
  infrastructure:
    web_servers: ["nginx_1.18", "nginx_1.20", "apache_2.4"]
    operating_systems: ["ubuntu_20.04", "ubuntu_22.04", "centos_7", "centos_8"]
    container_platforms: ["docker_20", "docker_24", "kubernetes_1.27", "kubernetes_1.28"]
```

---

## **2. Автоматизация конфигурационного тестирования**

### **2.1. Docker Compose для тестовых окружений**

```yaml
# docker-compose.config-test.yml
version: '3.8'

services:
  # База данных PostgreSQL
  postgres-13:
    image: postgres:13
    environment:
      POSTGRES_DB: ecommerce_test
      POSTGRES_USER: test_user
      POSTGRES_PASSWORD: test_password
    ports:
      - "5433:5432"
    networks:
      - test-network

  postgres-14:
    image: postgres:14
    environment:
      POSTGRES_DB: ecommerce_test
      POSTGRES_USER: test_user
      POSTGRES_PASSWORD: test_password
    ports:
      - "5434:5432"
    networks:
      - test-network

  postgres-15:
    image: postgres:15
    environment:
      POSTGRES_DB: ecommerce_test
      POSTGRES_USER: test_user
      POSTGRES_PASSWORD: test_password
    ports:
      - "5435:5432"
    networks:
      - test-network

  # Redis для кэширования
  redis-6:
    image: redis:6-alpine
    ports:
      - "6380:6379"
    networks:
      - test-network

  redis-7:
    image: redis:7-alpine
    ports:
      - "6381:6379"
    networks:
      - test-network

  # Memcached
  memcached:
    image: memcached:1.6-alpine
    ports:
      - "11212:11211"
    networks:
      - test-network

  # Приложение с разными версиями Python
  app-python-38:
    build:
      context: .
      dockerfile: Dockerfile.python38
    environment:
      DATABASE_URL: postgres://test_user:test_password@postgres-14:5432/ecommerce_test
      REDIS_URL: redis://redis-7:6379/0
      DEBUG: "True"
    ports:
      - "8001:8000"
    depends_on:
      - postgres-14
      - redis-7
    networks:
      - test-network

  app-python-311:
    build:
      context: .
      dockerfile: Dockerfile.python311
    environment:
      DATABASE_URL: postgres://test_user:test_password@postgres-15:5432/ecommerce_test
      REDIS_URL: redis://redis-7:6379/0
      DEBUG: "True"
    ports:
      - "8004:8000"
    depends_on:
      - postgres-15
      - redis-7
    networks:
      - test-network

networks:
  test-network:
    driver: bridge
```

### **2.2. Конфигурационные файлы для разных сред**

```python
# config/settings/test_postgresql_13.py
from .base import *

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': 'ecommerce_test',
        'USER': 'test_user',
        'PASSWORD': 'test_password',
        'HOST': 'localhost',
        'PORT': '5433',
        'TEST': {
            'NAME': 'test_ecommerce_pg13',
        }
    }
}

# Настройки кэширования для тестов
CACHES = {
    'default': {
        'BACKEND': 'django_redis.cache.RedisCache',
        'LOCATION': 'redis://localhost:6381/1',
        'OPTIONS': {
            'CLIENT_CLASS': 'django_redis.client.DefaultClient',
        }
    }
}

# Специфичные настройки для PostgreSQL 13
DATABASE_OPTIONS = {
    'isolation_level': 'read committed',
    'timezone': 'UTC'
}
```

```python
# config/settings/test_redis_6.py
from .base import *

CACHES = {
    'default': {
        'BACKEND': 'django_redis.cache.RedisCache',
        'LOCATION': 'redis://localhost:6380/1',
        'OPTIONS': {
            'CLIENT_CLASS': 'django_redis.client.DefaultClient',
            'SOCKET_CONNECT_TIMEOUT': 5,
            'SOCKET_TIMEOUT': 5,
            'RETRY_ON_TIMEOUT': True,
        }
    },
    'session': {
        'BACKEND': 'django_redis.cache.RedisCache',
        'LOCATION': 'redis://localhost:6380/2',
        'OPTIONS': {
            'CLIENT_CLASS': 'django_redis.client.DefaultClient',
        }
    }
}

# Настройки сессий
SESSION_ENGINE = 'django.contrib.sessions.backends.cache'
SESSION_CACHE_ALIAS = 'session'
```

---

## **3. Тесты для разных конфигураций**

### **3.1. Базовый класс для конфигурационного тестирования**

```python
# tests/config_test_base.py
import os
import pytest
from django.test import TestCase, override_settings
from django.conf import settings
from django.db import connection

class ConfigurationTestBase(TestCase):
    """Базовый класс для конфигурационного тестирования"""
    
    @classmethod
    def setUpClass(cls):
        super().setUpClass()
        cls.current_config = cls._get_current_configuration()
    
    @classmethod
    def _get_current_configuration(cls):
        """Получение текущей конфигурации системы"""
        return {
            'python_version': f"{sys.version_info.major}.{sys.version_info.minor}",
            'django_version': django.get_version(),
            'database_engine': settings.DATABASES['default']['ENGINE'],
            'database_version': cls._get_database_version(),
            'cache_backend': list(settings.CACHES.keys())[0],
            'debug_mode': settings.DEBUG,
        }
    
    @classmethod
    def _get_database_version(cls):
        """Получение версии базы данных"""
        try:
            with connection.cursor() as cursor:
                if 'postgresql' in settings.DATABASES['default']['ENGINE']:
                    cursor.execute("SELECT version()")
                    version = cursor.fetchone()[0]
                    return version.split(' ')[1]
                elif 'sqlite' in settings.DATABASES['default']['ENGINE']:
                    cursor.execute("SELECT sqlite_version()")
                    return cursor.fetchone()[0]
        except Exception as e:
            return f"Unknown: {str(e)}"
    
    def assertConfigurationCompatible(self, feature, min_version=None, max_version=None):
        """Проверка совместимости конфигурации с фичей"""
        config = self.current_config
        
        if min_version and config['python_version'] < min_version:
            pytest.skip(f"{feature} requires Python >= {min_version}")
        
        if max_version and config['python_version'] > max_version:
            pytest.skip(f"{feature} not tested with Python > {max_version}")
        
        return True
```

### **3.2. Тесты для разных версий Python**

```python
# tests/config/test_python_versions.py
import sys
import pytest
from tests.config_test_base import ConfigurationTestBase

class TestPythonCompatibility(ConfigurationTestBase):
    """Тесты совместимости с разными версиями Python"""
    
    def test_python_version_specific_features(self):
        """Тестирование фич, специфичных для версий Python"""
        python_version = sys.version_info
        
        # Тесты для Python 3.8+
        if python_version >= (3, 8):
            # Проверка использования walrus operator
            result = [name for product in self.products if (name := product.get('name'))]
            self.assertIsInstance(result, list)
        
        # Тесты для Python 3.9+
        if python_version >= (3, 9):
            # Проверка аннотаций типов
            from typing import Annotated
            test_var: Annotated[str, "Test annotation"] = "test"
            self.assertEqual(test_var, "test")
        
        # Тесты для Python 3.10+
        if python_version >= (3, 10):
            # Проверка pattern matching
            value = "success"
            match value:
                case "success":
                    result = True
                case _:
                    result = False
            self.assertTrue(result)
    
    def test_async_compatibility(self):
        """Тестирование асинхронной функциональности"""
        import asyncio
        
        async def async_operation():
            await asyncio.sleep(0.1)
            return "completed"
        
        # Запуск асинхронного теста
        result = asyncio.run(async_operation())
        self.assertEqual(result, "completed")
    
    @pytest.mark.skipif(sys.version_info < (3, 9), 
                       reason="Requires Python 3.9+ for zoneinfo")
    def test_timezone_handling(self):
        """Тестирование обработки временных зон (Python 3.9+)"""
        from zoneinfo import ZoneInfo
        from datetime import datetime
        
        moscow_tz = ZoneInfo("Europe/Moscow")
        dt = datetime(2024, 1, 1, 12, 0, tzinfo=moscow_tz)
        
        self.assertEqual(str(dt.tzinfo), "Europe/Moscow")
```

### **3.3. Тесты для разных баз данных**

```python
# tests/config/test_database_configs.py
import pytest
from django.db import connection, transaction
from tests.config_test_base import ConfigurationTestBase

class TestDatabaseCompatibility(ConfigurationTestBase):
    """Тесты совместимости с разными базами данных"""
    
    def test_database_specific_queries(self):
        """Тестирование специфичных SQL запросов"""
        db_engine = settings.DATABASES['default']['ENGINE']
        
        with connection.cursor() as cursor:
            # Тест JSON полей (PostgreSQL)
            if 'postgresql' in db_engine:
                cursor.execute("""
                    SELECT jsonb_typeof('{"test": "value"}'::jsonb) as json_type
                """)
                result = cursor.fetchone()
                self.assertEqual(result[0], 'object')
            
            # Тест полнотекстового поиска
            if 'postgresql' in db_engine:
                cursor.execute("""
                    SELECT to_tsvector('english', 'test search query') @@ to_tsquery('english', 'test')
                """)
                result = cursor.fetchone()
                self.assertTrue(result[0])
    
    def test_transaction_handling(self):
        """Тестирование обработки транзакций"""
        from modules.products.models import Product
        
        initial_count = Product.objects.count()
        
        try:
            with transaction.atomic():
                Product.objects.create(
                    name="Test Transaction Product",
                    price=100.00,
                    sku="TEST_TRANSACTION"
                )
                # Симулируем ошибку для проверки rollback
                if not getattr(self, 'test_commit', False):
                    raise Exception("Test rollback")
        except Exception:
            pass
        
        # Проверяем, что транзакция откатилась
        final_count = Product.objects.count()
        self.assertEqual(initial_count, final_count)
    
    def test_database_constraints(self):
        """Тестирование ограничений базы данных"""
        from django.db import IntegrityError
        from modules.products.models import Product
        
        # Создаем продукт с уникальным SKU
        Product.objects.create(
            name="Test Product",
            price=100.00,
            sku="UNIQUE_SKU_TEST"
        )
        
        # Пытаемся создать дубликат
        with self.assertRaises(IntegrityError):
            Product.objects.create(
                name="Duplicate Product",
                price=200.00,
                sku="UNIQUE_SKU_TEST"
            )
    
    @pytest.mark.parametrize("batch_size", [100, 1000, 10000])
    def test_bulk_operations(self, batch_size):
        """Тестирование массовых операций"""
        from modules.products.models import Product
        
        products = [
            Product(
                name=f"Bulk Product {i}",
                price=i * 10.0,
                sku=f"BULK_{i}"
            )
            for i in range(batch_size)
        ]
        
        # Массовое создание
        created = Product.objects.bulk_create(products, batch_size=1000)
        self.assertEqual(len(created), batch_size)
        
        # Массовое обновление
        for product in created:
            product.price += 5.0
        
        updated = Product.objects.bulk_update(created, ['price'], batch_size=1000)
        self.assertEqual(updated, batch_size)
```

### **3.4. Тесты для систем кэширования**

```python
# tests/config/test_cache_configs.py
import time
import pytest
from django.core.cache import cache, caches
from tests.config_test_base import ConfigurationTestBase

class TestCacheCompatibility(ConfigurationTestBase):
    """Тесты совместимости с разными системами кэширования"""
    
    def setUp(self):
        super().setUp()
        cache.clear()
    
    def test_basic_cache_operations(self):
        """Тестирование базовых операций кэширования"""
        # Set и Get
        cache.set('test_key', 'test_value', 60)
        value = cache.get('test_key')
        self.assertEqual(value, 'test_value')
        
        # Delete
        cache.delete('test_key')
        value = cache.get('test_key')
        self.assertIsNone(value)
        
        # Increment/Decrement
        cache.set('counter', 10, 60)
        cache.incr('counter')
        self.assertEqual(cache.get('counter'), 11)
        cache.decr('counter')
        self.assertEqual(cache.get('counter'), 10)
    
    def test_cache_timeout_handling(self):
        """Тестирование обработки времени жизни кэша"""
        cache.set('temp_key', 'temp_value', 1)  # 1 секунда
        
        # Проверяем, что значение есть
        self.assertEqual(cache.get('temp_key'), 'temp_value')
        
        # Ждем истечения времени
        time.sleep(1.1)
        
        # Проверяем, что значение удалилось
        self.assertIsNone(cache.get('temp_key'))
    
    def test_cache_backend_specific_features(self):
        """Тестирование специфичных фич бэкендов кэширования"""
        cache_backend = settings.CACHES['default']['BACKEND']
        
        if 'redis' in cache_backend:
            # Тестируем Redis-specific фичи
            redis_cache = caches['default']
            
            # Проверяем подключение к Redis
            self.assertTrue(redis_cache.client.get_client().ping())
            
            # Тестируем операции с множествами
            redis_cache.client.get_client().sadd('test_set', 'member1', 'member2')
            members = redis_cache.client.get_client().smembers('test_set')
            self.assertEqual(len(members), 2)
        
        elif 'memcached' in cache_backend:
            # Тестируем Memcached-specific фичи
            memcached_cache = caches['default']
            
            # Memcached имеет ограничения на размер ключа
            long_key = 'x' * 250  # Слишком длинный ключ
            with self.assertRaises(Exception):
                memcached_cache.set(long_key, 'value', 60)
    
    def test_session_cache_integration(self):
        """Тестирование интеграции кэша с сессиями"""
        from django.contrib.sessions.backends.cache import SessionStore
        
        session = SessionStore()
        session['test_session_key'] = 'test_session_value'
        session.save()
        
        # Проверяем, что сессия сохранилась в кэше
        session_key = session.session_key
        self.assertIsNotNone(session_key)
        
        # Загружаем сессию заново
        new_session = SessionStore(session_key)
        self.assertEqual(new_session['test_session_key'], 'test_session_value')
```

---

## **4. Selenium тесты для разных браузеров**

### **4.1. Конфигурация Selenium Grid**

```python
# tests/selenium/config/browser_configs.py
from selenium import webdriver
from selenium.webdriver.common.desired_capabilities import DesiredCapabilities

class BrowserConfig:
    """Конфигурация для разных браузеров"""
    
    @staticmethod
    def get_chrome_options(version="120"):
        """Настройки для Chrome"""
        options = webdriver.ChromeOptions()
        options.add_argument('--headless')
        options.add_argument('--no-sandbox')
        options.add_argument('--disable-dev-shm-usage')
        options.add_argument('--disable-gpu')
        options.add_argument('--window-size=1920,1080')
        
        # Версия-specific настройки
        if version >= "121":
            options.add_argument('--disable-blink-features=AutomationControlled')
        
        return options
    
    @staticmethod
    def get_firefox_options(version="115"):
        """Настройки для Firefox"""
        options = webdriver.FirefoxOptions()
        options.add_argument('--headless')
        options.add_argument('--width=1920')
        options.add_argument('--height=1080')
        
        # Версия-specific настройки
        if version >= "116":
            options.set_preference("dom.webnotifications.enabled", False)
        
        return options
    
    @staticmethod
    def get_safari_options(version="16"):
        """Настройки для Safari"""
        # Safari не поддерживает headless режим через Selenium
        capabilities = DesiredCapabilities.SAFARI.copy()
        
        if version >= "17":
            capabilities['safari:automaticInspection'] = True
        
        return capabilities
    
    @staticmethod
    def get_mobile_config(device="chrome_mobile"):
        """Настройки для мобильных устройств"""
        mobile_emulation = {
            "deviceName": "iPhone 12 Pro"
        }
        
        options = webdriver.ChromeOptions()
        options.add_experimental_option("mobileEmulation", mobile_emulation)
        
        return options
```

### **4.2. Кросс-браузерные тесты**

```python
# tests/selenium/test_cross_browser.py
import pytest
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from tests.selenium.config.browser_configs import BrowserConfig

@pytest.mark.parametrize("browser_config", [
    {"browser": "chrome", "version": "120"},
    {"browser": "chrome", "version": "121"},
    {"browser": "firefox", "version": "115"},
    {"browser": "firefox", "version": "116"},
    {"browser": "safari", "version": "16"},
])
class TestCrossBrowserCompatibility:
    """Кросс-браузерное тестирование"""
    
    def setUp(self):
        self.base_url = "http://localhost:8000"
    
    def get_driver(self, browser_config):
        """Создание драйвера для конкретного браузера"""
        browser = browser_config["browser"]
        version = browser_config["version"]
        
        if browser == "chrome":
            options = BrowserConfig.get_chrome_options(version)
            driver = webdriver.Chrome(options=options)
        elif browser == "firefox":
            options = BrowserConfig.get_firefox_options(version)
            driver = webdriver.Firefox(options=options)
        elif browser == "safari":
            capabilities = BrowserConfig.get_safari_options(version)
            driver = webdriver.Safari(desired_capabilities=capabilities)
        
        driver.implicitly_wait(10)
        return driver
    
    def test_homepage_loading(self, browser_config):
        """Тест загрузки главной страницы"""
        driver = self.get_driver(browser_config)
        
        try:
            driver.get(f"{self.base_url}/")
            
            # Проверяем основные элементы
            wait = WebDriverWait(driver, 10)
            
            # Логотип
            logo = wait.until(
                EC.presence_of_element_located((By.CSS_SELECTOR, ".navbar-brand"))
            )
            self.assertTrue(logo.is_displayed())
            
            # Поисковая строка
            search_input = driver.find_element(By.CSS_SELECTOR, "input[type='search']")
            self.assertTrue(search_input.is_displayed())
            
            # Корзина
            cart_icon = driver.find_element(By.CSS_SELECTOR, ".cart-icon")
            self.assertTrue(cart_icon.is_displayed())
            
            # Проверяем заголовок
            self.assertIn("ShopStore", driver.title)
            
        finally:
            driver.quit()
    
    def test_product_search_functionality(self, browser_config):
        """Тест функциональности поиска товаров"""
        driver = self.get_driver(browser_config)
        
        try:
            driver.get(f"{self.base_url}/")
            
            # Вводим поисковый запрос
            search_input = driver.find_element(By.CSS_SELECTOR, "input[type='search']")
            search_input.send_keys("test product")
            
            # Нажимаем кнопку поиска
            search_button = driver.find_element(By.CSS_SELECTOR, ".search-button")
            search_button.click()
            
            # Ждем результатов
            wait = WebDriverWait(driver, 10)
            results = wait.until(
                EC.presence_of_element_located((By.CSS_SELECTOR, ".search-results"))
            )
            
            # Проверяем, что результаты отобразились
            self.assertTrue(results.is_displayed())
            
            # Проверяем CSS свойства (браузер-специфичные)
            computed_style = driver.execute_script(
                "return window.getComputedStyle(arguments[0]).display;", results
            )
            self.assertEqual(computed_style, "block")
            
        finally:
            driver.quit()
    
    def test_shopping_cart_functionality(self, browser_config):
        """Тест функциональности корзины"""
        driver = self.get_driver(browser_config)
        
        try:
            driver.get(f"{self.base_url}/products/1")
            
            # Добавляем товар в корзину
            add_to_cart_button = WebDriverWait(driver, 10).until(
                EC.element_to_be_clickable((By.CSS_SELECTOR, ".add-to-cart"))
            )
            add_to_cart_button.click()
            
            # Проверяем уведомление
            notification = WebDriverWait(driver, 10).until(
                EC.presence_of_element_located((By.CSS_SELECTOR, ".cart-notification"))
            )
            self.assertTrue(notification.is_displayed())
            
            # Переходим в корзину
            cart_link = driver.find_element(By.CSS_SELECTOR, ".cart-link")
            cart_link.click()
            
            # Проверяем, что товар в корзине
            cart_item = WebDriverWait(driver, 10).until(
                EC.presence_of_element_located((By.CSS_SELECTOR, ".cart-item"))
            )
            self.assertTrue(cart_item.is_displayed())
            
        finally:
            driver.quit()
```

---

## **5. Тестирование разных инфраструктурных конфигураций**

### **5.1. Тесты для разных веб-серверов**

```python
# tests/infrastructure/test_web_servers.py
import requests
import pytest
import time
from tests.config_test_base import ConfigurationTestBase

class TestWebServerCompatibility(ConfigurationTestBase):
    """Тестирование совместимости с разными веб-серверами"""
    
    @pytest.mark.parametrize("web_server", ["nginx", "apache"])
    def test_static_files_serving(self, web_server):
        """Тестирование обслуживания статических файлов"""
        if web_server == "nginx":
            base_url = "http://localhost:8080"  # Nginx порт
        else:
            base_url = "http://localhost:8081"  # Apache порт
        
        # Тестируем CSS файлы
        css_response = requests.get(f"{base_url}/static/css/main.css")
        self.assertEqual(css_response.status_code, 200)
        self.assertIn("text/css", css_response.headers.get('content-type', ''))
        
        # Тестируем JavaScript файлы
        js_response = requests.get(f"{base_url}/static/js/app.js")
        self.assertEqual(js_response.status_code, 200)
        self.assertIn("application/javascript", js_response.headers.get('content-type', ''))
        
        # Тестируем изображения
        img_response = requests.get(f"{base_url}/static/images/logo.png")
        self.assertEqual(img_response.status_code, 200)
        self.assertIn("image/png", img_response.headers.get('content-type', ''))
    
    def test_gzip_compression(self):
        """Тестирование GZIP сжатия"""
        response = requests.get(
            "http://localhost:8000/",
            headers={'Accept-Encoding': 'gzip'}
        )
        
        # Проверяем, что сжатие работает
        self.assertIn('gzip', response.headers.get('content-encoding', ''))
        
        # Проверяем, что размер уменьшился
        uncompressed_size = len(response.content)
        
        # Запрос без сжатия для сравнения
        response_uncompressed = requests.get(
            "http://localhost:8000/",
            headers={'Accept-Encoding': 'identity'}
        )
        compressed_size = len(response_uncompressed.content)
        
        # Сжатие должно уменьшить размер
        self.assertLess(uncompressed_size, compressed_size)
    
    def test_caching_headers(self):
        """Тестирование заголовков кэширования"""
        response = requests.get("http://localhost:8000/static/css/main.css")
        
        # Проверяем заголовки кэширования
        self.assertIn('cache-control', response.headers)
        self.assertIn('etag', response.headers)
        
        cache_control = response.headers['cache-control']
        self.assertIn('public', cache_control)
        self.assertIn('max-age', cache_control)
```

### **5.2. Тесты для разных операционных систем**

```python
# tests/infrastructure/test_os_compatibility.py
import platform
import os
import pytest
from tests.config_test_base import ConfigurationTestBase

class TestOSCompatibility(ConfigurationTestBase):
    """Тестирование совместимости с разными ОС"""
    
    def test_file_path_handling(self):
        """Тестирование обработки путей файлов"""
        current_os = platform.system().lower()
        
        # Тестируем создание путей
        if current_os == 'windows':
            test_path = "C:\\test\\directory\\file.txt"
            expected_separator = "\\"
        else:
            test_path = "/test/directory/file.txt"
            expected_separator = "/"
        
        # Проверяем, что пути обрабатываются корректно
        directory = os.path.dirname(test_path)
        self.assertIn(expected_separator, directory)
    
    def test_environment_variables(self):
        """Тестирование переменных окружения"""
        # Устанавливаем тестовую переменную
        os.environ['TEST_ENV_VAR'] = 'test_value'
        
        # Проверяем, что приложение видит переменную
        from django.conf import settings
        self.assertEqual(os.environ.get('TEST_ENV_VAR'), 'test_value')
        
        # Очищаем
        del os.environ['TEST_ENV_VAR']
    
    def test_temp_file_operations(self):
        """Тестирование операций с временными файлами"""
        import tempfile
        
        # Создаем временный файл
        with tempfile.NamedTemporaryFile(mode='w+', delete=False) as temp_file:
            temp_file.write("test content")
            temp_path = temp_file.name
        
        # Проверяем, что файл создан
        self.assertTrue(os.path.exists(temp_path))
        
        # Читаем содержимое
        with open(temp_path, 'r') as f:
            content = f.read()
        
        self.assertEqual(content, "test content")
        
        # Удаляем
        os.unlink(temp_path)
        self.assertFalse(os.path.exists(temp_path))
    
    @pytest.mark.skipif(platform.system() != 'Linux', 
                       reason="Linux-specific test")
    def test_linux_specific_features(self):
        """Тестирование Linux-специфичных фич"""
        # Проверяем использование inotify для мониторинга файлов
        try:
            import inotify.adapters
            self.assertTrue(True)  # inotify доступен
        except ImportError:
            self.skipTest("inotify not available")
    
    @pytest.mark.skipif(platform.system() != 'Windows', 
                       reason="Windows-specific test")
    def test_windows_specific_features(self):
        """Тестирование Windows-специфичных фич"""
        # Проверяем работу с Windows Registry
        try:
            import winreg
            self.assertTrue(True)  # winreg доступен
        except ImportError:
            self.skipTest("winreg not available")
```

---

## **6. Автоматизация запуска тестов**

### **6.1. Скрипт для запуска конфигурационных тестов**

```python
#!/usr/bin/env python
# scripts/run_configuration_tests.py
import os
import sys
import subprocess
import json
import argparse
from datetime import datetime

class ConfigurationTestRunner:
    """Запуск конфигурационных тестов"""
    
    def __init__(self):
        self.results = {}
        self.test_start_time = datetime.now()
    
    def run_tests_for_configuration(self, config_name, settings_module):
        """Запуск тестов для конкретной конфигурации"""
        print(f"\n🔧 Running tests for {config_name}...")
        
        env = os.environ.copy()
        env['DJANGO_SETTINGS_MODULE'] = settings_module
        
        # Команда для запуска тестов
        cmd = [
            'python', 'manage.py', 'test',
            'tests/config/',
            'tests/infrastructure/',
            '--verbosity=2',
            '--no-input',
            f'--junitxml=reports/{config_name}_results.xml'
        ]
        
        try:
            result = subprocess.run(
                cmd,
                env=env,
                capture_output=True,
                text=True,
                timeout=300  # 5 минут таймаут
            )
            
            test_result = {
                'config_name': config_name,
                'exit_code': result.returncode,
                'stdout': result.stdout,
                'stderr': result.stderr,
                'success': result.returncode == 0,
                'timestamp': datetime.now().isoformat()
            }
            
            if result.returncode == 0:
                print(f"✅ {config_name}: PASSED")
            else:
                print(f"❌ {config_name}: FAILED")
                print(f"Error: {result.stderr}")
            
            return test_result
            
        except subprocess.TimeoutExpired:
            print(f"⏰ {config_name}: TIMEOUT")
            return {
                'config_name': config_name,
                'exit_code': -1,
                'stdout': '',
                'stderr': 'Test timeout',
                'success': False,
                'timeout': True
            }
    
    def run_all_configurations(self):
        """Запуск тестов для всех конфигураций"""
        configurations = [
            ('PostgreSQL 13 + Redis 6', 'config.settings.test_postgresql_13_redis_6'),
            ('PostgreSQL 14 + Redis 7', 'config.settings.test_postgresql_14_redis_7'),
            ('PostgreSQL 15 + Memcached', 'config.settings.test_postgresql_15_memcached'),
            ('SQLite Development', 'config.settings.dev'),
        ]
        
        for config_name, settings_module in configurations:
            result = self.run_tests_for_configuration(config_name, settings_module)
            self.results[config_name] = result
        
        self.generate_report()
    
    def generate_report(self):
        """Генерация отчета о тестировании"""
        report = {
            'test_run': {
                'start_time': self.test_start_time.isoformat(),
                'end_time': datetime.now().isoformat(),
                'duration_seconds': (datetime.now() - self.test_start_time).total_seconds(),
            },
            'configurations': self.results,
            'summary': {
                'total_configs': len(self.results),
                'passed_configs': sum(1 for r in self.results.values() if r['success']),
                'failed_configs': sum(1 for r in self.results.values() if not r['success']),
                'success_rate': (sum(1 for r in self.results.values() if r['success']) / len(self.results)) * 100
            }
        }
        
        # Сохраняем отчет
        os.makedirs('reports', exist_ok=True)
        with open('reports/configuration_test_report.json', 'w') as f:
            json.dump(report, f, indent=2)
        
        # Выводим сводку
        print("\n" + "="*50)
        print("CONFIGURATION TESTING SUMMARY")
        print("="*50)
        print(f"Total configurations: {report['summary']['total_configs']}")
        print(f"Passed: {report['summary']['passed_configs']}")
        print(f"Failed: {report['summary']['failed_configs']}")
        print(f"Success rate: {report['summary']['success_rate']:.1f}%")
        print("="*50)
        
        # Показываем неудачные конфигурации
        failed_configs = [name for name, result in self.results.items() if not result['success']]
        if failed_configs:
            print("\n❌ FAILED CONFIGURATIONS:")
            for config in failed_configs:
                print(f"  - {config}")

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Run configuration tests')
    parser.add_argument('--config', help='Specific configuration to test')
    
    args = parser.parse_args()
    
    runner = ConfigurationTestRunner()
    
    if args.config:
        # Запуск конкретной конфигурации
        config_mapping = {
            'pg13_redis6': ('PostgreSQL 13 + Redis 6', 'config.settings.test_postgresql_13_redis_6'),
            'pg14_redis7': ('PostgreSQL 14 + Redis 7', 'config.settings.test_postgresql_14_redis_7'),
        }
        
        if args.config in config_mapping:
            config_name, settings_module = config_mapping[args.config]
            runner.run_tests_for_configuration(config_name, settings_module)
        else:
            print(f"Unknown configuration: {args.config}")
    else:
        # Запуск всех конфигураций
        runner.run_all_configurations()
```

### **6.2. GitHub Actions для конфигурационного тестирования**

```yaml
# .github/workflows/configuration-tests.yml
name: Configuration Tests

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  configuration-matrix:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-20.04, ubuntu-22.04, windows-latest, macos-latest]
        python-version: ['3.8', '3.9', '3.10', '3.11']
        database: [postgresql-13, postgresql-14, postgresql-15]
        include:
          - database: postgresql-13
            db-port: 5433
          - database: postgresql-14
            db-port: 5434
          - database: postgresql-15
            db-port: 5435
    
    services:
      postgres:
        image: postgres:${{ matrix.database }}
        env:
          POSTGRES_USER: test_user
          POSTGRES_PASSWORD: test_password
          POSTGRES_DB: ecommerce_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - ${{ matrix.db-port }}:5432
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Python ${{ matrix.python-version }}
      uses: actions/setup-python@v4
      with:
        python-version: ${{ matrix.python-version }}
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install -r requirements-test.txt
    
    - name: Setup test database
      run: |
        python manage.py migrate --settings=config.settings.test
    
    - name: Run configuration tests
      env:
        DATABASE_URL: postgresql://test_user:test_password@localhost:${{ matrix.db-port }}/ecommerce_test
        DJANGO_SETTINGS_MODULE: config.settings.test
      run: |
        python scripts/run_configuration_tests.py
    
    - name: Upload test results
      uses: actions/upload-artifact@v3
      with:
        name: test-results-${{ matrix.os }}-py${{ matrix.python-version }}-${{ matrix.database }}
        path: reports/
        retention-days: 30
    
    - name: Publish Test Results
      uses: dorny/test-reporter@v1
      if: always()
      with:
        name: Configuration Tests
        path: reports/*.xml
        reporter: java-junit
```

---

## **7. Мониторинг и отчетность**

### **7.1. Генератор отчетов о совместимости**

```python
# scripts/generate_compatibility_report.py
import json
import matplotlib.pyplot as plt
import pandas as pd
from datetime import datetime

class CompatibilityReportGenerator:
    """Генератор отчетов о совместимости"""
    
    def __init__(self, test_results_file):
        with open(test_results_file, 'r') as f:
            self.results = json.load(f)
    
    def generate_compatibility_matrix(self):
        """Генерация матрицы совместимости"""
        config_data = []
        
        for config_name, result in self.results['configurations'].items():
            config_data.append({
                'Configuration': config_name,
                'Status': 'PASS' if result['success'] else 'FAIL',
                'Python Version': self._extract_python_version(config_name),
                'Database': self._extract_database(config_name),
                'Cache': self._extract_cache(config_name),
                'Test Duration': result.get('duration_seconds', 0),
                'Errors': len(result.get('stderr', '').split('\n')) if result.get('stderr') else 0
            })
        
        df = pd.DataFrame(config_data)
        
        # Создаем визуализацию
        self._create_compatibility_chart(df)
        
        return df
    
    def _extract_python_version(self, config_name):
        """Извлечение версии Python из названия конфигурации"""
        if 'Python 3.8' in config_name:
            return '3.8'
        elif 'Python 3.9' in config_name:
            return '3.9'
        elif 'Python 3.10' in config_name:
            return '3.10'
        elif 'Python 3.11' in config_name:
            return '3.11'
        return 'Unknown'
    
    def _create_compatibility_chart(self, df):
        """Создание диаграммы совместимости"""
        fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(15, 10))
        
        # Статус по конфигурациям
        status_counts = df['Status'].value_counts()
        ax1.pie(status_counts.values, labels=status_counts.index, autopct='%1.1f%%')
        ax1.set_title('Test Results Distribution')
        
        # Совместимость по версиям Python
        python_compat = df.groupby('Python Version')['Status'].value_counts().unstack()
        python_compat.plot(kind='bar', ax=ax2)
        ax2.set_title('Compatibility by Python Version')
        ax2.tick_params(axis='x', rotation=45)
        
        # Совместимость по базам данных
        db_compat = df.groupby('Database')['Status'].value_counts().unstack()
        db_compat.plot(kind='bar', ax=ax3)
        ax3.set_title('Compatibility by Database')
        ax3.tick_params(axis='x', rotation=45)
        
        # Время выполнения тестов
        df.boxplot(column='Test Duration', by='Python Version', ax=ax4)
        ax4.set_title('Test Duration by Python Version')
        
        plt.tight_layout()
        plt.savefig('reports/compatibility_matrix.png', dpi=300, bbox_inches='tight')
        plt.close()

if __name__ == '__main__':
    generator = CompatibilityReportGenerator('reports/configuration_test_report.json')
    matrix = generator.generate_compatibility_matrix()
    
    print("Compatibility Matrix:")
    print(matrix.to_string(index=False))
```

Данная система конфигурационного тестирования обеспечивает:

1. **Всестороннее покрытие** различных конфигураций системы
2. **Автоматизированное тестирование** совместимости компонентов
3. **Раннее обнаружение** проблем совместимости
4. **Детальную отчетность** о статусе совместимости
5. **Интеграцию с CI/CD** для непрерывного мониторинга

Это позволяет гарантировать стабильную работу интернет-магазина во всех поддерживаемых окружениях.
